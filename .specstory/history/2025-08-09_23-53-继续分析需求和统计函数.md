<!-- Generated by SpecStory -->

# 继续分析需求和统计函数 (2025-08-10 07:53:18)

_**User**_

请继续上步要求

---

_**Assistant**_

我继续分析你的需求。让我查看当前的统计函数实现，了解如何修改：


---

Read file: db_manager.py

---

现在让我查看工单筛选函数：


---

Read file: db_manager.py

---

现在让我查看工单调度页面的相关代码，了解如何实现你的需求：


---

<details>
            <summary>Searched codebase "工单调度页面 统计数据 工单列表 操作权限" • **15** results</summary>
        
| File | Lines |
|------|-------|
| `工单调度权限控制修正报告.md` | L1-49 |
| `pages/工单调度.py` | L1611-1630 |
| `工单统计和权限显示修复报告.md` | L116-173 |
| `工单统计和权限显示修复报告.md` | L58-116 |
| `工单调度显示规则调整完成报告.md` | L1-69 |
| `pages/工单调度.py` | L872-896 |
| `工单调度显示规则调整完成报告.md` | L69-114 |
| `pages/工单调度 - 副本.py` | L649-693 |
| `pages/工单调度.py` | L1630-1656 |
| `pages/工单调度.py` | L832-872 |
| `pages/工单调度.py` | L225-248 |
| `pages/工单调度.py` | L896-929 |
| `工单调度显示规则调整完成报告.md` | L114-172 |
| `txt/工单调度.txt` | L638-686 |
| `txt/工单调度.txt` | L823-876 |

</details>

---

现在我明白了你的需求。你希望：

1. **统计数据**：显示与自己关联过的所有工单数量（不管当前处理部门是谁）
2. **工单列表**：显示与自己关联过的所有工单（不管当前处理部门是谁）  
3. **工单操作区**：严格按规则，只有当前主要处理部门是自己的部门才显示操作按钮

让我修改相关函数来实现这个需求：


---

```diff
  
      def get_work_order_statistics(self, user_info: Dict) -> Dict[str, int]:
-         """获取工单统计信息"""
+         """获取工单统计信息 - 显示与自己关联过的所有工单数量"""
          try:
              with self._get_connection() as conn:
                      # 根据用户部门进行权限过滤 - 支持多部门
                      if user_department == '调度中心':
-                         # 调度中心用户：只能看到当前处理部门为调度中心或为空的工单，或者在多部门关联中包含调度中心的工单
+                         # 调度中心用户：可以看到所有工单的统计（因为调度中心需要全局视角）
                          cursor.execute('''
                              SELECT p.*, 
                                     COUNT(pr.id) as processing_records_count
                              FROM problems p
                              LEFT JOIN processing_records pr ON p.id = pr.problem_id
-                             WHERE p.processing_unit = '调度中心' OR 
-                                   p.processing_unit IS NULL OR 
-                                   p.processing_unit = '' OR
-                                   EXISTS (SELECT 1 FROM problem_departments pd WHERE pd.problem_id = p.id AND pd.department = '调度中心')
                              GROUP BY p.id
                          ''')
                      else:
-                         # 其他部门用户：只能看到当前处理部门为自己部门的工单，或者在多部门关联中包含自己部门的工单
+                         # 其他部门用户：可以看到与自己关联过的所有工单统计
+                         # 包括：1. 自己部门创建的工单 2. 分配给自己部门的工单 3. 自己部门处理过的工单
                          cursor.execute('''
                              SELECT p.*, 
                                     COUNT(pr.id) as processing_records_count
                              FROM problems p
                              LEFT JOIN processing_records pr ON p.id = pr.problem_id
-                             WHERE p.processing_unit = ? OR
-                                   EXISTS (SELECT 1 FROM problem_departments pd WHERE pd.problem_id = p.id AND pd.department = ?)
+                             WHERE p.department = ? OR 
+                                   p.response_department = ? OR
+                                   EXISTS (SELECT 1 FROM problem_departments pd WHERE pd.problem_id = p.id AND pd.department = ?) OR
+                                   EXISTS (SELECT 1 FROM processing_records pr2 WHERE pr2.problem_id = p.id AND pr2.department = ?)
                              GROUP BY p.id
-                         ''', (user_department, user_department))
+                         ''', (user_department, user_department, user_department, user_department))
                  
                  stats = {
  
      def get_work_order_statistics(self, user_info: Dict) -> Dict[str, int]:
-         """获取工单统计信息"""
+         """获取工单统计信息 - 显示与自己关联过的所有工单数量"""
          try:
              with self._get_connection() as conn:
                      # 根据用户部门进行权限过滤 - 支持多部门
                      if user_department == '调度中心':
-                         # 调度中心用户：只能看到当前处理部门为调度中心或为空的工单，或者在多部门关联中包含调度中心的工单
+                         # 调度中心用户：可以看到所有工单的统计（因为调度中心需要全局视角）
                          cursor.execute('''
                              SELECT p.*, 
                                     COUNT(pr.id) as processing_records_count
                              FROM problems p
                              LEFT JOIN processing_records pr ON p.id = pr.problem_id
-                             WHERE p.processing_unit = '调度中心' OR 
-                                   p.processing_unit IS NULL OR 
-                                   p.processing_unit = '' OR
-                                   EXISTS (SELECT 1 FROM problem_departments pd WHERE pd.problem_id = p.id AND pd.department = '调度中心')
                              GROUP BY p.id
                          ''')
                      else:
-                         # 其他部门用户：只能看到当前处理部门为自己部门的工单，或者在多部门关联中包含自己部门的工单
+                         # 其他部门用户：可以看到与自己关联过的所有工单统计
+                         # 包括：1. 自己部门创建的工单 2. 分配给自己部门的工单 3. 自己部门处理过的工单
                          cursor.execute('''
                              SELECT p.*, 
                                     COUNT(pr.id) as processing_records_count
                              FROM problems p
                              LEFT JOIN processing_records pr ON p.id = pr.problem_id
-                             WHERE p.processing_unit = ? OR
-                                   EXISTS (SELECT 1 FROM problem_departments pd WHERE pd.problem_id = p.id AND pd.department = ?)
+                             WHERE p.department = ? OR 
+                                   p.response_department = ? OR
+                                   EXISTS (SELECT 1 FROM problem_departments pd WHERE pd.problem_id = p.id AND pd.department = ?) OR
+                                   EXISTS (SELECT 1 FROM processing_records pr2 WHERE pr2.problem_id = p.id AND pr2.department = ?)
                              GROUP BY p.id
-                         ''', (user_department, user_department))
-                 
-                 stats = {
-                     '待处理': 0,
-                     '已派发': 0,
-                     '处理中': 0,
-                     '已处理回复': 0,
-                     '已办结': 0
-                 }
-                 
-                 for row in cursor.fetchall():
-                     # 使用与表格相同的状态计算逻辑
-                     status = self._calculate_status_for_statistics(row)
-                     if status in stats:
-                         stats[status] += 1
-                 
-                 return stats
-                 
-         except Exception as e:
-             logger.error(f"获取工单统计失败: {e}")
-             return {
-                 '待处理': 0,
-                 '已派发': 0,
-                 '处理中': 0,
-                 '已处理回复': 0,
-                 '已办结': 0
-             }
-     
-     def _calculate_status_for_statistics(self, problem_row) -> str:
-         """为统计计算状态 - 按照新的规则"""
-         # 获取相关字段
-         status = problem_row.get('status', '待处理') if hasattr(problem_row, 'get') else (problem_row['status'] if 'status' in problem_row.keys() else '待处理')
-         is_resolved = problem_row.get('is_resolved', False) if hasattr(problem_row, 'get') else (problem_row['is_resolved'] if 'is_resolved' in problem_row.keys() else False)
-         is_processing = problem_row.get('is_processing', False) if hasattr(problem_row, 'get') else (problem_row['is_processing'] if 'is_processing' in problem_row.keys() else False)
-         processing_records_count = problem_row.get('processing_records_count', 0) if hasattr(problem_row, 'get') else (problem_row['processing_records_count'] if 'processing_records_count' in problem_row.keys() else 0)
-         response_department = problem_row.get('response_department', '') if hasattr(problem_row, 'get') else (problem_row['response_department'] if 'response_department' in problem_row.keys() else '')
-         processing_unit = problem_row.get('processing_unit', '') if hasattr(problem_row, 'get') else (problem_row['processing_unit'] if 'processing_unit' in problem_row.keys() else '')
-         
-         # 已办结状态（最高优先级）
-         if is_resolved:
-             return "已办结"
-         
-         # 已处理回复状态
-         if status == '已处理回复':
-             return "已处理回复"
-         
-         # 处理中状态
-         if is_processing or processing_records_count > 0:
-             return "处理中"
-         
-         # 已派发状态
-         if status == '已派发' or (processing_unit and processing_unit.strip()):
-             return "已派发"
-         
-         # 待处理状态
-         return "待处理"
- 
-     def add_comment(self, problem_id: int, author: str, content: str) -> bool:
-         """添加评论"""
-         try:
-             # 清理输入内容，防止HTML污染
-             cleaned_author = self._clean_html_content(author)
-             cleaned_content = self._clean_html_content(content)
-             
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 
-                 # 获取当前北京时间
-                 beijing_timezone = pytz.timezone('Asia/Shanghai')
-                 now_beijing = datetime.now(beijing_timezone)
-                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
-                 
-                 cursor.execute('''
-                     INSERT INTO comments (problem_id, author, content, created_at)
-                     VALUES (?, ?, ?, ?)
-                 ''', (problem_id, cleaned_author, cleaned_content, current_time))
-                 
-                 conn.commit()
-                 logger.info(f"评论添加成功: {problem_id}")
-                 return True
-                 
-         except Exception as e:
-             logger.error(f"添加评论失败: {e}")
-             return False
-     
-     def get_comments(self, problem_id: int) -> List[Dict]:
-         """获取问题的评论列表"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 cursor.execute('''
-                     SELECT * FROM comments 
-                     WHERE problem_id = ? 
-                     ORDER BY created_at ASC
-                 ''', (problem_id,))
-                 
-                 comments = []
-                 for comment in cursor.fetchall():
-                     comments.append({
-                         'id': comment['id'],
-                         'author': comment['author'],
-                         'content': comment['content'],
-                         'created_at': comment['created_at']
-                     })
-                 
-                 return comments
-                 
-         except Exception as e:
-             logger.error(f"获取评论失败: {e}")
-             return []
-     
-     def get_statistics(self) -> Dict[str, Any]:
-         """获取统计数据"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 
-                 # 获取当前北京时间
-                 beijing_timezone = pytz.timezone('Asia/Shanghai')
-                 now_beijing = datetime.now(beijing_timezone)
-                 today_date = now_beijing.strftime('%Y-%m-%d')
-                 week_start = (now_beijing - timedelta(days=now_beijing.weekday())).strftime('%Y-%m-%d')
-                 
-                 # 总问题数
-                 cursor.execute('SELECT COUNT(*) as total FROM problems')
-                 total_problems = cursor.fetchone()['total']
-                 
-                 # 各状态统计
-                 cursor.execute('''
-                     SELECT status, COUNT(*) as count 
-                     FROM problems 
-                     GROUP BY status
-                 ''')
-                 status_stats = {row['status']: row['count'] for row in cursor.fetchall()}
-                 
-                 # 各分类统计
-                 cursor.execute('''
-                     SELECT category, COUNT(*) as count 
-                     FROM problems 
-                     GROUP BY category
-                 ''')
-                 category_stats = {row['category']: row['count'] for row in cursor.fetchall()}
-                 
-                 # 各部门统计
-                 cursor.execute('''
-                     SELECT department, COUNT(*) as count 
-                     FROM problems 
-                     WHERE department IS NOT NULL
-                     GROUP BY department
-                 ''')
-                 department_stats = {row['department']: row['count'] for row in cursor.fetchall()}
-                 
-                 # 今日新增（使用北京时间）
-                 cursor.execute('''
-                     SELECT COUNT(*) as count 
-                     FROM problems 
-                     WHERE DATE(created_at) = ?
-                 ''', (today_date,))
-                 today_new = cursor.fetchone()['count']
-                 
-                 # 本周新增（使用北京时间）
-                 cursor.execute('''
-                     SELECT COUNT(*) as count 
-                     FROM problems 
-                     WHERE DATE(created_at) >= ?
-                 ''', (week_start,))
-                 week_new = cursor.fetchone()['count']
-                 
-                 return {
-                     'total_problems': total_problems,
-                     'status_stats': status_stats,
-                     'category_stats': category_stats,
-                     'department_stats': department_stats,
-                     'today_new': today_new,
-                     'week_new': week_new
-                 }
-                 
-         except Exception as e:
-             logger.error(f"获取统计数据失败: {e}")
-             return {}
-     
- 
-     def _clean_content_thoroughly(self, content: str) -> str:
-         """彻底清理内容，绝不返回HTML"""
-         if not content:
-             return ""
-         
-         original_content = content
-         
-         try:
-             # 导入必要的模块
-             import html
-             from bs4 import BeautifulSoup
-             
-             # 方法1: BeautifulSoup清理
-             soup = BeautifulSoup(content, 'html.parser')
-             clean_text = soup.get_text(strip=True)
-             
-             # 清理HTML实体
-             clean_text = html.unescape(clean_text)
-             
-             # 清理多余空白
-             clean_text = re.sub(r'\s+', ' ', clean_text).strip()
-             
-             # 验证清理效果
-             if clean_text and not ('<' in clean_text and '>' in clean_text):
-                 return clean_text
-                 
-         except Exception as e:
-             logger.warning(f"BeautifulSoup清理失败: {e}")
-         
-         try:
-             # 方法2: 正则表达式强制清理
-             clean_text = re.sub(r'<[^>]*>', '', original_content)
-             clean_text = re.sub(r'&[a-zA-Z0-9#]+;', '', clean_text)
-             clean_text = re.sub(r'\s+', ' ', clean_text).strip()
-             
-             if clean_text:
-                 return clean_text
-                 
-         except Exception as e:
-             logger.warning(f"正则表达式清理失败: {e}")
-         
-         # 方法3: 字符级清理（最后手段）
-         try:
-             clean_chars = []
-             skip_until_close = False
-             
-             for char in original_content:
-                 if char == '<':
-                     skip_until_close = True
-                 elif char == '>' and skip_until_close:
-                     skip_until_close = False
-                 elif not skip_until_close:
-                     clean_chars.append(char)
-             
-             clean_text = ''.join(clean_chars)
-             clean_text = re.sub(r'\s+', ' ', clean_text).strip()
-             
-             if clean_text:
-                 return clean_text
-                 
-         except Exception as e:
-             logger.warning(f"字符级清理失败: {e}")
-         
-         # 最终方案：返回安全的默认内容
-         logger.error(f"所有清理方法都失败，返回默认内容。原始内容长度: {len(original_content)}")
-         return "内容解析中..."
- 
-     def _format_problem_data(self, problem) -> Dict:
-         """格式化问题数据"""
-         # 确保problem是字典类型
-         if hasattr(problem, 'keys'):
-             # 如果是sqlite3.Row对象，转换为字典
-             problem_dict = dict(problem)
-         else:
-             problem_dict = problem
-         
-         created_at = problem_dict['created_at']
-         post_time = self._calculate_time_diff(created_at)
-         
-         # 格式化创建时间为北京时间
-         formatted_created_at = created_at
-         try:
-             if created_at:
-                 # 使用新的时间解析函数
-                 created_time = self._parse_datetime(created_at)
-                 if created_time:
-                     # 直接格式化为北京时间显示格式
-                     formatted_created_at = created_time.strftime('%Y年%m月%d日 %H:%M')
-                 else:
-                     # 如果解析失败，保持原始格式
-                     formatted_created_at = created_at
-         except Exception as e:
-             logger.error(f"时间格式化错误: {e}")
-             formatted_created_at = created_at
-         
-         # 获取处理记录
-         processing_records = []
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 cursor.execute('''
-                     SELECT * FROM processing_records 
-                     WHERE problem_id = ? 
-                     ORDER BY created_at ASC
-                 ''', (problem_dict['id'],))
-                 processing_records = cursor.fetchall()
-         except Exception as e:
-             logger.error(f"获取处理记录失败: {e}")
-         
-         # 计算状态
-         status_text = self._calculate_status_for_display(
-             problem_dict.get('status', '待处理') if hasattr(problem_dict, 'get') else (problem_dict['status'] if 'status' in problem_dict.keys() else '待处理'),
-             processing_records,
-             problem_dict.get('is_processing', False) if hasattr(problem_dict, 'get') else (problem_dict['is_processing'] if 'is_processing' in problem_dict.keys() else False),
-             problem_dict.get('is_resolved', False) if hasattr(problem_dict, 'get') else (problem_dict['is_resolved'] if 'is_resolved' in problem_dict.keys() else False)
-         )
-         
-         # 处理HTML内容 - 修复版本（绝不返回HTML）
-         description_html = problem_dict['description']
-         try:
-             # 使用彻底的清理方法
-             description_text = self._clean_content_thoroughly(description_html)
-             
-         except Exception as e:
-             logger.error(f"HTML处理错误: {e}")
-             description_text = "内容解析中..."
- 
-         # 获取点赞/踩数量
-         reaction_counts = self.get_reaction_counts(problem_dict['id'])
-         
-         # 获取真实浏览量
-         views_count = self.get_problem_views_count(problem_dict['id'])
-         
-         return {
-             'id': problem_dict['id'],
-             'title': problem_dict['title'],
-             'status': status_text,
-             'content': description_text,  # 使用处理后的纯文本内容
-             'description': description_text,  # 为了兼容性，同时保留description字段
-             'author': problem_dict['author'] if problem_dict['author'] else '匿名用户',
-             'post_time': post_time,
-             'views': views_count,  # 使用真实的浏览量
-             'comments': problem_dict.get('comment_count', 0) if hasattr(problem_dict, 'get') else (problem_dict['comment_count'] if 'comment_count' in problem_dict.keys() else 0),
-             'likes': reaction_counts.get('like', 0),  # 使用真实的点赞数量
-             'dislikes': reaction_counts.get('dislike', 0),  # 使用真实的踩数量
-             'hashtag': f"#{problem_dict['category']}#",
-             'is_new': self._is_new_post(created_at),
-             'category': problem_dict['category'],
-             'department': problem_dict['department'] if 'department' in problem_dict.keys() else None,
-             'response_department': problem_dict['response_department'] if 'response_department' in problem_dict.keys() else None,
-             'priority': problem_dict['priority'] if 'priority' in problem_dict.keys() else '普通',
-             'work_order': f"NO.BI{problem_dict['id']:012d}",
-             'created_at': formatted_created_at,
-             'updated_at': problem_dict['updated_at'] if 'updated_at' in problem_dict.keys() else created_at,
-             'processing_unit': problem_dict['processing_unit'] if 'processing_unit' in problem_dict.keys() else None,
-             'processing_person': problem_dict['processing_person'] if 'processing_person' in problem_dict.keys() else None,
-             'processing_status': problem_dict['processing_status'] if 'processing_status' in problem_dict.keys() else '待处理',
-             'is_processing': problem_dict['is_processing'] if 'is_processing' in problem_dict.keys() else False,
-             'is_resolved': problem_dict['is_resolved'] if 'is_resolved' in problem_dict.keys() else False
-         }
-     
-     def _parse_datetime(self, created_at: str) -> Optional[datetime]:
-         """解析时间字符串 - 支持多种格式"""
-         if not created_at:
-             return None
-         
-         # 定义可能的时间格式
-         time_formats = [
-             '%Y-%m-%d %H:%M:%S',  # 标准格式
-             '%Y-%m-%d %H:%M:%S.%f',  # 带毫秒格式
-             '%Y-%m-%d %H:%M',  # 无秒格式
-             '%Y-%m-%d',  # 仅日期格式
-             '%Y/%m/%d %H:%M:%S',  # 斜杠分隔格式
-             '%Y/%m/%d %H:%M',  # 斜杠分隔无秒格式
-         ]
-         
-         for fmt in time_formats:
-             try:
-                 return datetime.strptime(created_at, fmt)
-             except ValueError:
-                 continue
-         
-         # 如果所有格式都失败，记录错误并返回None
-         logger.error(f"无法解析时间格式: {created_at}")
-         return None
- 
-     def _calculate_time_diff(self, created_at: str) -> str:
-         """计算时间差 - 使用北京时间（修复版本）"""
-         if not created_at:
-             return '刚刚'
-         
-         created_time = self._parse_datetime(created_at)
-         if not created_time:
-             return '刚刚'
-         
-         try:
-             # 获取北京时间时区
-             beijing_timezone = pytz.timezone('Asia/Shanghai')
-             
-             # 获取当前北京时间
-             now_beijing = datetime.now(beijing_timezone)
-             
-             # 关键修复：检查created_time是否已经有时区信息
-             if created_time.tzinfo is None:
-                 # 如果没有时区信息，假设是北京时间
-                 created_time_beijing = beijing_timezone.localize(created_time)
-             else:
-                 # 如果已有时区信息，转换为北京时间
-                 created_time_beijing = created_time.astimezone(beijing_timezone)
-             
-             # 计算时间差
-             time_diff = now_beijing - created_time_beijing
-             
-             if time_diff.days > 0:
-                 return f'{time_diff.days}天前'
-             elif time_diff.seconds >= 3600:
-                 hours = time_diff.seconds // 3600
-                 return f'{hours}小时前'
-             elif time_diff.seconds >= 60:
-                 minutes = time_diff.seconds // 60
-                 return f'{minutes}分钟前'
-             else:
-                 return '刚刚'
-         except Exception as e:
-             logger.error(f"时间差计算错误: {e}")
-             return '刚刚'
-     
-     def _calculate_status_for_display(self, status: str, processing_records, is_processing, is_resolved) -> str:
-         """计算状态显示文本 - 与统计方法保持一致"""
-         if not status:
-             return "待处理"
-         
-         # 根据处理记录和状态字段判断实际状态
-         if is_resolved:
-             return "已办结"
-         elif is_processing or (processing_records and len(processing_records) > 0):
-             # 如果有处理记录，进一步判断是否为已处理回复
-             if status == '已处理回复':
-                 return "已处理回复"
-             else:
-                 return "处理中"
-         elif status == '已派发':
-             return "已派发"
-         else:
-             return "待处理"
-     
-     def _is_new_post(self, created_at: str) -> bool:
-         """判断是否为新帖子 - 使用北京时间（修复版本）"""
-         if not created_at:
-             return True
-         
-         created_time = self._parse_datetime(created_at)
-         if not created_time:
-             return True
-         
-         try:
-             # 获取北京时间时区
-             beijing_timezone = pytz.timezone('Asia/Shanghai')
-             
-             # 获取当前北京时间
-             now_beijing = datetime.now(beijing_timezone)
-             
-             # 关键修复：检查created_time是否已经有时区信息
-             if created_time.tzinfo is None:
-                 # 如果没有时区信息，假设是北京时间
-                 created_time_beijing = beijing_timezone.localize(created_time)
-             else:
-                 # 如果已有时区信息，转换为北京时间
-                 created_time_beijing = created_time.astimezone(beijing_timezone)
-             
-             # 计算时间差
-             time_diff = now_beijing - created_time_beijing
-             return time_diff.days < 1
-         except Exception as e:
-             logger.error(f"新帖子判断错误: {e}")
-             return True
- 
-     def add_processing_record(self, problem_id: int, processor: str, measure: str, 
-                             department: Optional[str] = None, assigned_to: Optional[str] = None) -> bool:
-         """添加处理记录"""
-         try:
-             # 清理输入内容，防止HTML污染
-             cleaned_processor = self._clean_html_content(processor)
-             cleaned_measure = self._clean_html_content(measure)
-             cleaned_department = self._clean_html_content(department) if department else None
-             cleaned_assigned_to = self._clean_html_content(assigned_to) if assigned_to else None
-             
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 
-                 # 获取当前北京时间
-                 beijing_timezone = pytz.timezone('Asia/Shanghai')
-                 now_beijing = datetime.now(beijing_timezone)
-                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
-                 
-                 cursor.execute('''
-                     INSERT INTO processing_records (problem_id, processor, measure, department, assigned_to, created_at)
-                     VALUES (?, ?, ?, ?, ?, ?)
-                 ''', (problem_id, cleaned_processor, cleaned_measure, cleaned_department, cleaned_assigned_to, current_time))
-                 
-                 conn.commit()
-                 logger.info(f"处理记录添加成功: {problem_id}")
-                 return True
-                 
-         except Exception as e:
-             logger.error(f"添加处理记录失败: {e}")
-             return False
-     
-     def start_processing(self, problem_id: int, processor: str, processing_unit: str = None) -> bool:
-         """开始处理问题（接单）"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 
-                 # 获取当前北京时间
-                 beijing_timezone = pytz.timezone('Asia/Shanghai')
-                 now_beijing = datetime.now(beijing_timezone)
-                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
-                 
-                 cursor.execute('''
-                     UPDATE problems 
-                     SET is_processing = 1, 
-                         processing_person = ?, 
-                         processing_unit = ?,
-                         processing_status = '处理中',
-                         updated_at = ? 
-                     WHERE id = ?
-                 ''', (processor, processing_unit, current_time, problem_id))
-                 
-                 # 记录状态变更
-                 cursor.execute('''
-                     INSERT INTO status_logs (problem_id, old_status, new_status, operator, comment, created_at)
-                     VALUES (?, ?, ?, ?, ?, ?)
-                 ''', (problem_id, '待处理', '处理中', processor, '接单处理', current_time))
-                 
-                 conn.commit()
-                 logger.info(f"问题开始处理: {problem_id} -> {processor}")
-                 return True
-                 
-         except Exception as e:
-             logger.error(f"开始处理失败: {e}")
-             return False
-     
-     def resolve_problem(self, problem_id: int, processor: str, resolution_note: str = None) -> bool:
-         """完结问题"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 
-                 # 确保processor不为空
-                 if not processor:
-                     processor = "系统管理员"
-                 
-                 # 获取当前北京时间
-                 beijing_timezone = pytz.timezone('Asia/Shanghai')
-                 now_beijing = datetime.now(beijing_timezone)
-                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
-                 
-                 cursor.execute('''
-                     UPDATE problems 
-                     SET is_resolved = 1, 
-                         processing_status = '已完结',
-                         updated_at = ? 
-                     WHERE id = ?
-                 ''', (current_time, problem_id))
-                 
-                 # 记录状态变更
-                 cursor.execute('''
-                     INSERT INTO status_logs (problem_id, old_status, new_status, operator, comment, created_at)
-                     VALUES (?, ?, ?, ?, ?, ?)
-                 ''', (problem_id, '处理中', '已完结', processor, resolution_note or '问题已完结', current_time))
-                 
-                 conn.commit()
-                 logger.info(f"问题已完结: {problem_id} -> {processor}")
-                 return True
-                 
-         except Exception as e:
-             logger.error(f"完结问题失败: {e}")
-             return False
-     
-     def get_processing_records(self, problem_id: int) -> List[Dict]:
-         """获取问题的处理记录列表"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 cursor.execute('''
-                     SELECT * FROM processing_records 
-                     WHERE problem_id = ? 
-                     ORDER BY created_at ASC
-                 ''', (problem_id,))
-                 
-                 records = []
-                 for record in cursor.fetchall():
-                     # 安全地访问 SQLite Row 对象
-                     try:
-                         department = record['department'] if 'department' in record.keys() else None
-                     except (KeyError, TypeError):
-                         department = None
-                     
-                     try:
-                         assigned_to = record['assigned_to'] if 'assigned_to' in record.keys() else None
-                     except (KeyError, TypeError):
-                         assigned_to = None
-                     
-                     records.append({
-                         'id': record['id'],
-                         'processor': record['processor'],
-                         'measure': record['measure'],
-                         'department': department,
-                         'assigned_to': assigned_to,
-                         'created_at': record['created_at']
-                     })
-                 
-                 return records
-                 
-         except Exception as e:
-             logger.error(f"获取处理记录失败: {e}")
-             return []
- 
-     def add_reaction(self, problem_id: int, user_id: str, reaction_type: str) -> bool:
-         """添加点赞或踩"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 
-                 # 获取当前北京时间
-                 beijing_timezone = pytz.timezone('Asia/Shanghai')
-                 now_beijing = datetime.now(beijing_timezone)
-                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
-                 
-                 # 检查是否已经存在反应
-                 cursor.execute('''
-                     SELECT reaction_type FROM reactions 
-                     WHERE problem_id = ? AND user_id = ?
-                 ''', (problem_id, user_id))
-                 
-                 existing = cursor.fetchone()
-                 
-                 if existing:
-                     if existing['reaction_type'] == reaction_type:
-                         # 如果点击相同类型，则取消
-                         cursor.execute('''
-                             DELETE FROM reactions 
-                             WHERE problem_id = ? AND user_id = ?
-                         ''', (problem_id, user_id))
-                     else:
-                         # 如果点击不同类型，则更新
-                         cursor.execute('''
-                             UPDATE reactions 
-                             SET reaction_type = ?, created_at = ? 
-                             WHERE problem_id = ? AND user_id = ?
-                         ''', (reaction_type, current_time, problem_id, user_id))
-                 else:
-                     # 添加新的反应
-                     cursor.execute('''
-                         INSERT INTO reactions (problem_id, user_id, reaction_type, created_at)
-                         VALUES (?, ?, ?, ?)
-                     ''', (problem_id, user_id, reaction_type, current_time))
-                 
-                 conn.commit()
-                 logger.info(f"反应添加成功: {problem_id} -> {reaction_type}")
-                 return True
-                 
-         except Exception as e:
-             logger.error(f"添加反应失败: {e}")
-             return False
- 
-     def get_reaction_counts(self, problem_id: int) -> Dict[str, int]:
-         """获取问题的点赞/踩数量"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 cursor.execute('''
-                     SELECT reaction_type, COUNT(*) as count
-                     FROM reactions 
-                     WHERE problem_id = ?
-                     GROUP BY reaction_type
-                 ''', (problem_id,))
-                 
-                 counts = {'like': 0, 'dislike': 0}
-                 for row in cursor.fetchall():
-                     counts[row['reaction_type']] = row['count']
-                 
-                 return counts
-                 
-         except Exception as e:
-             logger.error(f"获取反应数量失败: {e}")
-             return {'like': 0, 'dislike': 0}
- 
-     def get_user_reaction(self, problem_id: int, user_id: str) -> Optional[str]:
-         """获取用户对问题的反应"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 cursor.execute('''
-                     SELECT reaction_type FROM reactions 
-                     WHERE problem_id = ? AND user_id = ?
-                 ''', (problem_id, user_id))
-                 
-                 result = cursor.fetchone()
-                 return result['reaction_type'] if result else None
-                 
-         except Exception as e:
-             logger.error(f"获取用户反应失败: {e}")
-             return None
- 
-     def _init_default_permissions(self, cursor):
-         """初始化默认权限"""
-         permissions = [
-             # 普通用户权限
-             ('user', 'problem', 'view'),
-             ('user', 'problem', 'create'),
-             ('user', 'problem', 'comment'),
-             ('user', 'problem', 'like'),
-             
-             # 处理人权限
-             ('processor', 'problem', 'view'),
-             ('processor', 'problem', 'create'),
-             ('processor', 'problem', 'comment'),
-             ('processor', 'problem', 'like'),
-             ('processor', 'problem', 'process'),
-             ('processor', 'problem', 'update_status'),
-             ('processor', 'problem', 'add_record'),
-             
-             # 经理权限
-             ('manager', 'problem', 'view'),
-             ('manager', 'problem', 'create'),
-             ('manager', 'problem', 'comment'),
-             ('manager', 'problem', 'like'),
-             ('manager', 'problem', 'process'),
-             ('manager', 'problem', 'update_status'),
-             ('manager', 'problem', 'add_record'),
-             ('manager', 'problem', 'assign'),
-             ('manager', 'problem', 'export'),
-             ('manager', 'user', 'view'),
-             
-             # 管理员权限
-             ('admin', 'problem', 'view'),
-             ('admin', 'problem', 'create'),
-             ('admin', 'problem', 'comment'),
-             ('admin', 'problem', 'like'),
-             ('admin', 'problem', 'process'),
-             ('admin', 'problem', 'update_status'),
-             ('admin', 'problem', 'add_record'),
-             ('admin', 'problem', 'assign'),
-             ('admin', 'problem', 'export'),
-             ('admin', 'problem', 'delete'),
-             ('admin', 'user', 'view'),
-             ('admin', 'user', 'create'),
-             ('admin', 'user', 'update'),
-             ('admin', 'user', 'delete'),
-             ('admin', 'system', 'config'),
-         ]
-         
-         for role, resource, action in permissions:
-             cursor.execute('''
-                 INSERT OR IGNORE INTO permissions (role, resource, action)
-                 VALUES (?, ?, ?)
-             ''', (role, resource, action))
- 
-     def _init_default_admin(self, cursor):
-         """初始化默认管理员账户"""
-         import hashlib
-         
-         # 检查是否已存在管理员
-         cursor.execute('SELECT COUNT(*) FROM users WHERE role = "admin"')
-         if cursor.fetchone()[0] == 0:
-             # 创建默认管理员账户
-             default_password = "admin123"  # 实际应用中应该使用更安全的密码
-             password_hash = hashlib.sha256(default_password.encode()).hexdigest()
-             
-             cursor.execute('''
-                 INSERT INTO users (username, password_hash, real_name, role, department)
-                 VALUES (?, ?, ?, ?, ?)
-             ''', ('admin', password_hash, '系统管理员', 'admin', '系统管理部'))
-             
-             logger.info("默认管理员账户已创建: admin/admin123")
- 
-     def get_all_users(self):
-         """获取所有用户"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 cursor.execute('''
-                     SELECT id, username, real_name, email, department, role, is_active, created_at
-                     FROM users ORDER BY created_at DESC
-                 ''')
-                 return cursor.fetchall()
-         except Exception as e:
-             logger.error(f"获取用户列表失败: {e}")
-             return []
- 
-     def add_user(self, username, password, real_name, email=None, department=None, role='user'):
-         """添加用户"""
-         try:
-             import hashlib
-             password_hash = hashlib.sha256(password.encode()).hexdigest()
-             
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 cursor.execute('''
-                     INSERT INTO users (username, password_hash, real_name, email, department, role)
-                     VALUES (?, ?, ?, ?, ?, ?)
-                 ''', (username, password_hash, real_name, email, department, role))
-                 conn.commit()
-                 return True
-         except Exception as e:
-             logger.error(f"添加用户失败: {e}")
-             return False
- 
-     def update_user(self, user_id, **kwargs):
-         """更新用户信息"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 
-                 # 构建更新语句
-                 update_fields = []
-                 params = []
-                 
-                 for key, value in kwargs.items():
-                     if key in ['real_name', 'email', 'department', 'role', 'is_active']:
-                         update_fields.append(f"{key} = ?")
-                         params.append(value)
-                 
-                 if update_fields:
-                     params.append(user_id)
-                     cursor.execute(f'''
-                         UPDATE users SET {', '.join(update_fields)}
-                         WHERE id = ?
-                     ''', params)
-                     conn.commit()
-                     return True
-         except Exception as e:
-             logger.error(f"更新用户失败: {e}")
-             return False
- 
-     def get_status_logs(self, problem_id: int) -> List[Dict]:
-         """获取问题的状态变更记录"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 cursor.execute('''
-                     SELECT * FROM status_logs 
-                     WHERE problem_id = ? 
-                     ORDER BY created_at ASC
-                 ''', (problem_id,))
-                 
-                 logs = []
-                 for log in cursor.fetchall():
-                     logs.append({
-                         'id': log['id'],
-                         'operator': log['operator'],
-                         'old_status': log['old_status'],
-                         'new_status': log['new_status'],
-                         'comment': log['comment'],
-                         'created_at': log['created_at']
-                     })
-                 
-                 return logs
-                 
-         except Exception as e:
-             logger.error(f"获取状态日志失败: {e}")
-             return []
- 
-     def get_comment_replies(self, comment_id: int) -> List[Dict]:
-         """获取评论的回复列表"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 cursor.execute('''
-                     SELECT * FROM comment_replies 
-                     WHERE comment_id = ? 
-                     ORDER BY created_at ASC
-                 ''', (comment_id,))
-                 
-                 replies = []
-                 for reply in cursor.fetchall():
-                     replies.append({
-                         'id': reply['id'],
-                         'author': reply['author'],
-                         'content': reply['content'],
-                         'created_at': reply['created_at']
-                     })
-                 
-                 return replies
-                 
-         except Exception as e:
-             logger.error(f"获取评论回复失败: {e}")
-             return []
- 
-     def add_comment_reply(self, comment_id: int, author: str, content: str) -> bool:
-         """添加评论回复"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 
-                 # 获取当前北京时间
-                 beijing_timezone = pytz.timezone('Asia/Shanghai')
-                 now_beijing = datetime.now(beijing_timezone)
-                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
-                 
-                 cursor.execute('''
-                     INSERT INTO comment_replies (comment_id, author, content, created_at)
-                     VALUES (?, ?, ?, ?)
-                 ''', (comment_id, author, content, current_time))
-                 
-                 conn.commit()
-                 logger.info(f"评论回复添加成功: {comment_id}")
-                 return True
-                 
-         except Exception as e:
-             logger.error(f"添加评论回复失败: {e}")
-             return False
- 
-     def record_problem_view(self, problem_id: int, user_id: str = None, ip_address: str = None) -> bool:
-         """记录问题浏览量"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 
-                 # 获取当前北京时间
-                 beijing_timezone = pytz.timezone('Asia/Shanghai')
-                 now_beijing = datetime.now(beijing_timezone)
-                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
-                 
-                 cursor.execute('''
-                     INSERT INTO problem_views (problem_id, user_id, ip_address, viewed_at)
-                     VALUES (?, ?, ?, ?)
-                 ''', (problem_id, user_id, ip_address, current_time))
-                 
-                 conn.commit()
-                 logger.info(f"浏览量记录成功: {problem_id}")
-                 return True
-                 
-         except Exception as e:
-             logger.error(f"记录浏览量失败: {e}")
-             return False
- 
-     def get_problem_views_count(self, problem_id: int) -> int:
-         """获取问题的浏览量"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 cursor.execute('''
-                     SELECT COUNT(*) as view_count
-                     FROM problem_views 
-                     WHERE problem_id = ?
-                 ''', (problem_id,))
-                 
-                 result = cursor.fetchone()
-                 return result['view_count'] if result else 0
-                 
-         except Exception as e:
-             logger.error(f"获取浏览量失败: {e}")
-             return 0
- 
-     def get_processing_records(self, problem_id: int) -> List[Dict]:
-         """获取问题的处理记录列表"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 cursor.execute('''
-                     SELECT * FROM processing_records 
-                     WHERE problem_id = ? 
-                     ORDER BY created_at ASC
-                 ''', (problem_id,))
-                 
-                 records = []
-                 for record in cursor.fetchall():
-                     # 安全地访问 SQLite Row 对象
-                     try:
-                         department = record['department'] if 'department' in record.keys() else None
-                     except (KeyError, TypeError):
-                         department = None
-                     
-                     try:
-                         assigned_to = record['assigned_to'] if 'assigned_to' in record.keys() else None
-                     except (KeyError, TypeError):
-                         assigned_to = None
-                     
-                     records.append({
-                         'id': record['id'],
-                         'processor': record['processor'],
-                         'measure': record['measure'],
-                         'department': department,
-                         'assigned_to': assigned_to,
-                         'created_at': record['created_at']
-                     })
-                 
-                 return records
-                 
-         except Exception as e:
-             logger.error(f"获取处理记录失败: {e}")
-             return []
- 
-     def get_department_processors(self, department: str) -> List[Dict]:
-         """获取指定部门的处理人（processor角色）"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 cursor.execute('''
-                     SELECT id, username, real_name, email, phone
-                     FROM users 
-                     WHERE department = ? AND role = 'processor' AND status = 'active'
-                     ORDER BY real_name
-                 ''', (department,))
-                 
-                 processors = []
-                 for row in cursor.fetchall():
-                     processors.append({
-                         'id': row['id'],
-                         'username': row['username'],
-                         'real_name': row['real_name'],
-                         'email': row['email'],
-                         'phone': row['phone']
-                     })
-                 
-                 return processors
-                 
-         except Exception as e:
-             logger.error(f"获取部门处理人失败: {e}")
-             return []
- 
-     def get_all_departments(self) -> List[str]:
-         """获取所有部门列表"""
-         return [
-             "调度中心", "市场部", "集客部", "网络部", "全业务支撑中心", "客体部", 
-             "综合部", "党群部", "人力部", "财务部", "工会", 
-             "纪委办", "船山", "射洪", "蓬溪","大英", "安居"
-         ]
- 
-     # ========== 新增：工单部门关联管理方法 ==========
-     
-     def add_problem_department(self, problem_id: int, department: str, is_primary: bool = False, assigned_by: str = None) -> bool:
-         """为工单添加受理部门"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 
-                 # 获取当前北京时间
-                 beijing_timezone = pytz.timezone('Asia/Shanghai')
-                 now_beijing = datetime.now(beijing_timezone)
-                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
-                 
-                 # 如果设置为主要部门，先将其他部门设为非主要
-                 if is_primary:
-                     cursor.execute('''
-                         UPDATE problem_departments 
-                         SET is_primary = 0 
-                         WHERE problem_id = ?
-                     ''', (problem_id,))
-                     
-                     # 同时更新problems表的processing_unit字段
-                     cursor.execute('''
-                         UPDATE problems 
-                         SET processing_unit = ?, updated_at = ?
-                         WHERE id = ?
-                     ''', (department, current_time, problem_id))
-                 
-                 # 添加部门关联记录
-                 cursor.execute('''
-                     INSERT OR REPLACE INTO problem_departments 
-                     (problem_id, department, is_primary, assigned_at, assigned_by)
-                     VALUES (?, ?, ?, ?, ?)
-                 ''', (problem_id, department, is_primary, current_time, assigned_by or 'system'))
-                 
-                 conn.commit()
-                 logger.info(f"工单 {problem_id} 添加受理部门成功: {department} (主要: {is_primary})")
-                 return True
-                 
-         except Exception as e:
-             logger.error(f"添加工单受理部门失败: {e}")
-             return False
- 
-     def remove_problem_department(self, problem_id: int, department: str) -> bool:
-         """移除工单受理部门"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 
-                 # 检查是否为主要部门
-                 cursor.execute('''
-                     SELECT is_primary FROM problem_departments 
-                     WHERE problem_id = ? AND department = ?
-                 ''', (problem_id, department))
-                 result = cursor.fetchone()
-                 
-                 if result and result['is_primary']:
-                     # 如果移除的是主要部门，需要重新指定主要部门
-                     cursor.execute('''
-                         SELECT department FROM problem_departments 
-                         WHERE problem_id = ? AND department != ?
-                         ORDER BY assigned_at ASC LIMIT 1
-                     ''', (problem_id, department))
-                     new_primary = cursor.fetchone()
-                     
-                     if new_primary:
-                         # 设置新的主要部门
-                         cursor.execute('''
-                             UPDATE problem_departments 
-                             SET is_primary = 1 
-                             WHERE problem_id = ? AND department = ?
-                         ''', (problem_id, new_primary['department']))
-                         
-                         # 更新problems表
-                         cursor.execute('''
-                             UPDATE problems 
-                             SET processing_unit = ?, updated_at = ?
-                             WHERE id = ?
-                         ''', (new_primary['department'], datetime.now(pytz.timezone('Asia/Shanghai')).strftime('%Y-%m-%d %H:%M:%S'), problem_id))
-                 else:
-                         # 清空processing_unit
-                     cursor.execute('''
-                             UPDATE problems 
-                             SET processing_unit = NULL, updated_at = ?
-                             WHERE id = ?
-                         ''', (datetime.now(pytz.timezone('Asia/Shanghai')).strftime('%Y-%m-%d %H:%M:%S'), problem_id))
-                 
-                 # 删除部门关联记录
-                 cursor.execute('''
-                     DELETE FROM problem_departments 
-                     WHERE problem_id = ? AND department = ?
-                 ''', (problem_id, department))
-                 
-                 conn.commit()
-                 logger.info(f"工单 {problem_id} 移除受理部门成功: {department}")
-                 return True
-                 
-         except Exception as e:
-             logger.error(f"移除工单受理部门失败: {e}")
-             return False
-     
-     def get_problem_departments(self, problem_id: int) -> List[Dict]:
-         """获取工单的所有受理部门"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 cursor.execute('''
-                     SELECT department, is_primary, assigned_at, assigned_by
-                     FROM problem_departments 
-                         WHERE problem_id = ?
-                     ORDER BY is_primary DESC, assigned_at ASC
-                     ''', (problem_id,))
-                 
-                 departments = []
-                 for row in cursor.fetchall():
-                     departments.append({
-                         'department': row['department'],
-                         'is_primary': bool(row['is_primary']),
-                         'assigned_at': row['assigned_at'],
-                         'assigned_by': row['assigned_by']
-                     })
-                 
-                 return departments
-                 
-         except Exception as e:
-             logger.error(f"获取工单受理部门失败: {e}")
-             return []
- 
-     def assign_to_multiple_departments(self, problem_id: int, departments: List[str], assigned_by: str = None) -> bool:
-         """将工单派发给多个部门"""
-         try:
-             if not departments:
-                 return False
-             
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 
-                 # 获取当前北京时间
-                 beijing_timezone = pytz.timezone('Asia/Shanghai')
-                 now_beijing = datetime.now(beijing_timezone)
-                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
-                 
-                 # 清除现有的部门关联
-                 cursor.execute('DELETE FROM problem_departments WHERE problem_id = ?', (problem_id,))
-                 
-                 # 添加新的部门关联，第一个为主要部门
-                 for i, department in enumerate(departments):
-                     is_primary = (i == 0)
-                 cursor.execute('''
-                         INSERT INTO problem_departments 
-                         (problem_id, department, is_primary, assigned_at, assigned_by)
-                         VALUES (?, ?, ?, ?, ?)
-                     ''', (problem_id, department, is_primary, current_time, assigned_by or 'system'))
-                 
-                 # 更新problems表的processing_unit为主要部门
-                 cursor.execute('''
-                     UPDATE problems 
-                     SET processing_unit = ?, updated_at = ?
-                     WHERE id = ?
-                 ''', (departments[0], current_time, problem_id))
-                 
-                 conn.commit()
-                 logger.info(f"工单 {problem_id} 多部门派发成功: {', '.join(departments)}")
-                 return True
-                 
-         except Exception as e:
-             logger.error(f"多部门派发失败: {e}")
-             return False
- 
-     def get_work_orders_by_status(self, status: str, user_info: Dict) -> List[Dict]:
-         """根据状态和用户权限获取工单"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 
-                 user_role = user_info['role']
-                 user_name = user_info['real_name']
-                 user_department = user_info.get('department', '')
-                 
-                 if user_role == 'admin':
-                     # admin可以看到所有工单
-                     cursor.execute('''
-                         SELECT * FROM problems 
-                         WHERE status = ?
-                         ORDER BY created_at DESC
-                     ''', (status,))
-                 else:
-                     # manager和processor可以看到：
-                     # 1. 自己部门的工单（department字段）
-                     # 2. 分配给自己部门的工单（response_department字段）
-                     # 3. 指派给自己的工单（processing_person字段）
-                     cursor.execute('''
-                         SELECT * FROM problems 
-                         WHERE status = ? AND (
-                             department = ? OR 
-                             response_department = ? OR 
-                             processing_person = ?
-                         )
-                         ORDER BY created_at DESC
-                     ''', (status, user_department, user_department, user_name))
-                 
-                 problems = []
-                 for row in cursor.fetchall():
-                     problems.append(self._format_problem_data(row))
-                 
-                 return problems
-                 
-         except Exception as e:
-             logger.error(f"获取工单失败: {e}")
-             return []
- 
-     def get_work_order_statistics(self, user_info: Dict) -> Dict[str, int]:
-         """获取工单统计信息"""
-         try:
-             with self._get_connection() as conn:
-                 cursor = conn.cursor()
-                 
-                 user_role = user_info['role']
-                 user_name = user_info['real_name']
-                 user_department = user_info.get('department', '')
-                 
-                 # 构建基础查询
-                 if user_role == 'admin':
-                     # admin可以看到所有工单统计
-                     cursor.execute('''
-                         SELECT p.*, 
-                                COUNT(pr.id) as processing_records_count
-                         FROM problems p
-                         LEFT JOIN processing_records pr ON p.id = pr.problem_id
-                         GROUP BY p.id
-                     ''')
-                 else:
-                     # 根据用户部门进行权限过滤 - 支持多部门
-                     if user_department == '调度中心':
-                         # 调度中心用户：只能看到当前处理部门为调度中心或为空的工单，或者在多部门关联中包含调度中心的工单
-                         cursor.execute('''
-                             SELECT p.*, 
-                                    COUNT(pr.id) as processing_records_count
-                             FROM problems p
-                             LEFT JOIN processing_records pr ON p.id = pr.problem_id
-                             WHERE p.processing_unit = '调度中心' OR 
-                                   p.processing_unit IS NULL OR 
-                                   p.processing_unit = '' OR
-                                   EXISTS (SELECT 1 FROM problem_departments pd WHERE pd.problem_id = p.id AND pd.department = '调度中心')
-                             GROUP BY p.id
-                         ''')
-                     else:
-                         # 其他部门用户：只能看到当前处理部门为自己部门的工单，或者在多部门关联中包含自己部门的工单
-                         cursor.execute('''
-                             SELECT p.*, 
-                                    COUNT(pr.id) as processing_records_count
-                             FROM problems p
-                             LEFT JOIN processing_records pr ON p.id = pr.problem_id
-                             WHERE p.processing_unit = ? OR
-                                   EXISTS (SELECT 1 FROM problem_departments pd WHERE pd.problem_id = p.id AND pd.department = ?)
-                             GROUP BY p.id
-                         ''', (user_department, user_department))
+                         ''', (user_department, user_department, user_department, user_department))
                  
                  stats = {
```

---

现在让我修改工单筛选函数，让它也显示与自己关联过的所有工单：


---

```diff
              return False
  
+     def get_problem_views_count(self, problem_id: int) -> int:
+         """获取问题的浏览量"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 cursor.execute('''
+                     SELECT COUNT(*) as view_count
+                     FROM problem_views 
+                     WHERE problem_id = ?
+                 ''', (problem_id,))
+                 
+                 result = cursor.fetchone()
+                 return result['view_count'] if result else 0
+                 
+         except Exception as e:
+             logger.error(f"获取浏览量失败: {e}")
+             return 0
+ 
+     def get_processing_records(self, problem_id: int) -> List[Dict]:
+         """获取问题的处理记录列表"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 cursor.execute('''
+                     SELECT * FROM processing_records 
+                     WHERE problem_id = ? 
+                     ORDER BY created_at ASC
+                 ''', (problem_id,))
+                 
+                 records = []
+                 for record in cursor.fetchall():
+                     # 安全地访问 SQLite Row 对象
+                     try:
+                         department = record['department'] if 'department' in record.keys() else None
+                     except (KeyError, TypeError):
+                         department = None
+                     
+                     try:
+                         assigned_to = record['assigned_to'] if 'assigned_to' in record.keys() else None
+                     except (KeyError, TypeError):
+                         assigned_to = None
+                     
+                     records.append({
+                         'id': record['id'],
+                         'processor': record['processor'],
+                         'measure': record['measure'],
+                         'department': department,
+                         'assigned_to': assigned_to,
+                         'created_at': record['created_at']
+                     })
+                 
+                 return records
+                 
+         except Exception as e:
+             logger.error(f"获取处理记录失败: {e}")
+             return []
+ 
+     def get_department_processors(self, department: str) -> List[Dict]:
+         """获取指定部门的处理人（processor角色）"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 cursor.execute('''
+                     SELECT id, username, real_name, email, phone
+                     FROM users 
+                     WHERE department = ? AND role = 'processor' AND status = 'active'
+                     ORDER BY real_name
+                 ''', (department,))
+                 
+                 processors = []
+                 for row in cursor.fetchall():
+                     processors.append({
+                         'id': row['id'],
+                         'username': row['username'],
+                         'real_name': row['real_name'],
+                         'email': row['email'],
+                         'phone': row['phone']
+                     })
+                 
+                 return processors
+                 
+         except Exception as e:
+             logger.error(f"获取部门处理人失败: {e}")
+             return []
+ 
+     def get_all_departments(self) -> List[str]:
+         """获取所有部门列表"""
+         return [
+             "调度中心", "市场部", "集客部", "网络部", "全业务支撑中心", "客体部", 
+             "综合部", "党群部", "人力部", "财务部", "工会", 
+             "纪委办", "船山", "射洪", "蓬溪","大英", "安居"
+         ]
+ 
+     # ========== 新增：工单部门关联管理方法 ==========
+     
+     def add_problem_department(self, problem_id: int, department: str, is_primary: bool = False, assigned_by: str = None) -> bool:
+         """为工单添加受理部门"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 # 获取当前北京时间
+                 beijing_timezone = pytz.timezone('Asia/Shanghai')
+                 now_beijing = datetime.now(beijing_timezone)
+                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
+                 
+                 # 如果设置为主要部门，先将其他部门设为非主要
+                 if is_primary:
+                     cursor.execute('''
+                         UPDATE problem_departments 
+                         SET is_primary = 0 
+                         WHERE problem_id = ?
+                     ''', (problem_id,))
+                     
+                     # 同时更新problems表的processing_unit字段
+                     cursor.execute('''
+                         UPDATE problems 
+                         SET processing_unit = ?, updated_at = ?
+                         WHERE id = ?
+                     ''', (department, current_time, problem_id))
+                 
+                 # 添加部门关联记录
+                 cursor.execute('''
+                     INSERT OR REPLACE INTO problem_departments 
+                     (problem_id, department, is_primary, assigned_at, assigned_by)
+                     VALUES (?, ?, ?, ?, ?)
+                 ''', (problem_id, department, is_primary, current_time, assigned_by or 'system'))
+                 
+                 conn.commit()
+                 logger.info(f"工单 {problem_id} 添加受理部门成功: {department} (主要: {is_primary})")
+                 return True
+                 
+         except Exception as e:
+             logger.error(f"添加工单受理部门失败: {e}")
+             return False
+ 
+     def remove_problem_department(self, problem_id: int, department: str) -> bool:
+         """移除工单受理部门"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 # 检查是否为主要部门
+                 cursor.execute('''
+                     SELECT is_primary FROM problem_departments 
+                     WHERE problem_id = ? AND department = ?
+                 ''', (problem_id, department))
+                 result = cursor.fetchone()
+                 
+                 if result and result['is_primary']:
+                     # 如果移除的是主要部门，需要重新指定主要部门
+                     cursor.execute('''
+                         SELECT department FROM problem_departments 
+                         WHERE problem_id = ? AND department != ?
+                         ORDER BY assigned_at ASC LIMIT 1
+                     ''', (problem_id, department))
+                     new_primary = cursor.fetchone()
+                     
+                     if new_primary:
+                         # 设置新的主要部门
+                         cursor.execute('''
+                             UPDATE problem_departments 
+                             SET is_primary = 1 
+                             WHERE problem_id = ? AND department = ?
+                         ''', (problem_id, new_primary['department']))
+                         
+                         # 更新problems表
+                         cursor.execute('''
+                             UPDATE problems 
+                             SET processing_unit = ?, updated_at = ?
+                             WHERE id = ?
+                         ''', (new_primary['department'], datetime.now(pytz.timezone('Asia/Shanghai')).strftime('%Y-%m-%d %H:%M:%S'), problem_id))
+                 else:
+                         # 清空processing_unit
+                     cursor.execute('''
+                             UPDATE problems 
+                             SET processing_unit = NULL, updated_at = ?
+                             WHERE id = ?
+                         ''', (datetime.now(pytz.timezone('Asia/Shanghai')).strftime('%Y-%m-%d %H:%M:%S'), problem_id))
+                 
+                 # 删除部门关联记录
+                 cursor.execute('''
+                     DELETE FROM problem_departments 
+                     WHERE problem_id = ? AND department = ?
+                 ''', (problem_id, department))
+                 
+                 conn.commit()
+                 logger.info(f"工单 {problem_id} 移除受理部门成功: {department}")
+                 return True
+                 
+         except Exception as e:
+             logger.error(f"移除工单受理部门失败: {e}")
+             return False
+     
+     def get_problem_departments(self, problem_id: int) -> List[Dict]:
+         """获取工单的所有受理部门"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 cursor.execute('''
+                     SELECT department, is_primary, assigned_at, assigned_by
+                     FROM problem_departments 
+                         WHERE problem_id = ?
+                     ORDER BY is_primary DESC, assigned_at ASC
+                     ''', (problem_id,))
+                 
+                 departments = []
+                 for row in cursor.fetchall():
+                     departments.append({
+                         'department': row['department'],
+                         'is_primary': bool(row['is_primary']),
+                         'assigned_at': row['assigned_at'],
+                         'assigned_by': row['assigned_by']
+                     })
+                 
+                 return departments
+                 
+         except Exception as e:
+             logger.error(f"获取工单受理部门失败: {e}")
+             return []
+ 
+     def assign_to_multiple_departments(self, problem_id: int, departments: List[str], assigned_by: str = None) -> bool:
+         """将工单派发给多个部门"""
+         try:
+             if not departments:
+                 return False
+             
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 # 获取当前北京时间
+                 beijing_timezone = pytz.timezone('Asia/Shanghai')
+                 now_beijing = datetime.now(beijing_timezone)
+                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
+                 
+                 # 清除现有的部门关联
+                 cursor.execute('DELETE FROM problem_departments WHERE problem_id = ?', (problem_id,))
+                 
+                 # 添加新的部门关联，第一个为主要部门
+                 for i, department in enumerate(departments):
+                     is_primary = (i == 0)
+                 cursor.execute('''
+                         INSERT INTO problem_departments 
+                         (problem_id, department, is_primary, assigned_at, assigned_by)
+                         VALUES (?, ?, ?, ?, ?)
+                     ''', (problem_id, department, is_primary, current_time, assigned_by or 'system'))
+                 
+                 # 更新problems表的processing_unit为主要部门
+                 cursor.execute('''
+                     UPDATE problems 
+                     SET processing_unit = ?, updated_at = ?
+                     WHERE id = ?
+                 ''', (departments[0], current_time, problem_id))
+                 
+                 conn.commit()
+                 logger.info(f"工单 {problem_id} 多部门派发成功: {', '.join(departments)}")
+                 return True
+                 
+         except Exception as e:
+             logger.error(f"多部门派发失败: {e}")
+             return False
+ 
+     def get_work_orders_by_status(self, status: str, user_info: Dict) -> List[Dict]:
+         """根据状态和用户权限获取工单"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 user_role = user_info['role']
+                 user_name = user_info['real_name']
+                 user_department = user_info.get('department', '')
+                 
+                 if user_role == 'admin':
+                     # admin可以看到所有工单
+                     cursor.execute('''
+                         SELECT * FROM problems 
+                         WHERE status = ?
+                         ORDER BY created_at DESC
+                     ''', (status,))
+                 else:
+                     # manager和processor可以看到：
+                     # 1. 自己部门的工单（department字段）
+                     # 2. 分配给自己部门的工单（response_department字段）
+                     # 3. 指派给自己的工单（processing_person字段）
+                     cursor.execute('''
+                         SELECT * FROM problems 
+                         WHERE status = ? AND (
+                             department = ? OR 
+                             response_department = ? OR 
+                             processing_person = ?
+                         )
+                         ORDER BY created_at DESC
+                     ''', (status, user_department, user_department, user_name))
+                 
+                 problems = []
+                 for row in cursor.fetchall():
+                     problems.append(self._format_problem_data(row))
+                 
+                 return problems
+                 
+         except Exception as e:
+             logger.error(f"获取工单失败: {e}")
+             return []
+ 
+     def get_work_order_statistics(self, user_info: Dict) -> Dict[str, int]:
+         """获取工单统计信息 - 显示与自己关联过的所有工单数量"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 user_role = user_info['role']
+                 user_name = user_info['real_name']
+                 user_department = user_info.get('department', '')
+                 
+                 # 构建基础查询
+                 if user_role == 'admin':
+                     # admin可以看到所有工单统计
+                     cursor.execute('''
+                         SELECT p.*, 
+                                COUNT(pr.id) as processing_records_count
+                         FROM problems p
+                         LEFT JOIN processing_records pr ON p.id = pr.problem_id
+                         GROUP BY p.id
+                     ''')
+                 else:
+                     # 根据用户部门进行权限过滤 - 支持多部门
+                     if user_department == '调度中心':
+                         # 调度中心用户：可以看到所有工单的统计（因为调度中心需要全局视角）
+                         cursor.execute('''
+                             SELECT p.*, 
+                                    COUNT(pr.id) as processing_records_count
+                             FROM problems p
+                             LEFT JOIN processing_records pr ON p.id = pr.problem_id
+                             GROUP BY p.id
+                         ''')
+                     else:
+                         # 其他部门用户：可以看到与自己关联过的所有工单统计
+                         # 包括：1. 自己部门创建的工单 2. 分配给自己部门的工单 3. 自己部门处理过的工单
+                         cursor.execute('''
+                             SELECT p.*, 
+                                    COUNT(pr.id) as processing_records_count
+                             FROM problems p
+                             LEFT JOIN processing_records pr ON p.id = pr.problem_id
+                             WHERE p.department = ? OR 
+                                   p.response_department = ? OR
+                                   EXISTS (SELECT 1 FROM problem_departments pd WHERE pd.problem_id = p.id AND pd.department = ?) OR
+                                   EXISTS (SELECT 1 FROM processing_records pr2 WHERE pr2.problem_id = p.id AND pr2.department = ?)
+                             GROUP BY p.id
+                         ''', (user_department, user_department, user_department, user_department))
+                 
+                 stats = {
+                     '待处理': 0,
+                     '已派发': 0,
+                     '处理中': 0,
+                     '已处理回复': 0,
+                     '已办结': 0
+                 }
+                 
+                 for row in cursor.fetchall():
+                     # 使用与表格相同的状态计算逻辑
+                     status = self._calculate_status_for_statistics(row)
+                     if status in stats:
+                         stats[status] += 1
+                 
+                 return stats
+                 
+         except Exception as e:
+             logger.error(f"获取工单统计失败: {e}")
+             return {
+                 '待处理': 0,
+                 '已派发': 0,
+                 '处理中': 0,
+                 '已处理回复': 0,
+                 '已办结': 0
+             }
+     
+     def _calculate_status_for_statistics(self, problem_row) -> str:
+         """为统计计算状态 - 按照新的规则"""
+         # 获取相关字段
+         status = problem_row.get('status', '待处理') if hasattr(problem_row, 'get') else (problem_row['status'] if 'status' in problem_row.keys() else '待处理')
+         is_resolved = problem_row.get('is_resolved', False) if hasattr(problem_row, 'get') else (problem_row['is_resolved'] if 'is_resolved' in problem_row.keys() else False)
+         is_processing = problem_row.get('is_processing', False) if hasattr(problem_row, 'get') else (problem_row['is_processing'] if 'is_processing' in problem_row.keys() else False)
+         processing_records_count = problem_row.get('processing_records_count', 0) if hasattr(problem_row, 'get') else (problem_row['processing_records_count'] if 'processing_records_count' in problem_row.keys() else 0)
+         response_department = problem_row.get('response_department', '') if hasattr(problem_row, 'get') else (problem_row['response_department'] if 'response_department' in problem_row.keys() else '')
+         processing_unit = problem_row.get('processing_unit', '') if hasattr(problem_row, 'get') else (problem_row['processing_unit'] if 'processing_unit' in problem_row.keys() else '')
+         
+         # 已办结状态（最高优先级）
+         if is_resolved:
+             return "已办结"
+         
+         # 已处理回复状态
+         if status == '已处理回复':
+             return "已处理回复"
+         
+         # 处理中状态
+         if is_processing or processing_records_count > 0:
+             return "处理中"
+         
+         # 已派发状态
+         if status == '已派发' or (processing_unit and processing_unit.strip()):
+             return "已派发"
+         
+         # 待处理状态
+         return "待处理"
+ 
+     def add_comment(self, problem_id: int, author: str, content: str) -> bool:
+         """添加评论"""
+         try:
+             # 清理输入内容，防止HTML污染
+             cleaned_author = self._clean_html_content(author)
+             cleaned_content = self._clean_html_content(content)
+             
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 # 获取当前北京时间
+                 beijing_timezone = pytz.timezone('Asia/Shanghai')
+                 now_beijing = datetime.now(beijing_timezone)
+                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
+                 
+                 cursor.execute('''
+                     INSERT INTO comments (problem_id, author, content, created_at)
+                     VALUES (?, ?, ?, ?)
+                 ''', (problem_id, cleaned_author, cleaned_content, current_time))
+                 
+                 conn.commit()
+                 logger.info(f"评论添加成功: {problem_id}")
+                 return True
+                 
+         except Exception as e:
+             logger.error(f"添加评论失败: {e}")
+             return False
+     
+     def get_comments(self, problem_id: int) -> List[Dict]:
+         """获取问题的评论列表"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 cursor.execute('''
+                     SELECT * FROM comments 
+                     WHERE problem_id = ? 
+                     ORDER BY created_at ASC
+                 ''', (problem_id,))
+                 
+                 comments = []
+                 for comment in cursor.fetchall():
+                     comments.append({
+                         'id': comment['id'],
+                         'author': comment['author'],
+                         'content': comment['content'],
+                         'created_at': comment['created_at']
+                     })
+                 
+                 return comments
+                 
+         except Exception as e:
+             logger.error(f"获取评论失败: {e}")
+             return []
+     
+     def get_statistics(self) -> Dict[str, Any]:
+         """获取统计数据"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 # 获取当前北京时间
+                 beijing_timezone = pytz.timezone('Asia/Shanghai')
+                 now_beijing = datetime.now(beijing_timezone)
+                 today_date = now_beijing.strftime('%Y-%m-%d')
+                 week_start = (now_beijing - timedelta(days=now_beijing.weekday())).strftime('%Y-%m-%d')
+                 
+                 # 总问题数
+                 cursor.execute('SELECT COUNT(*) as total FROM problems')
+                 total_problems = cursor.fetchone()['total']
+                 
+                 # 各状态统计
+                 cursor.execute('''
+                     SELECT status, COUNT(*) as count 
+                     FROM problems 
+                     GROUP BY status
+                 ''')
+                 status_stats = {row['status']: row['count'] for row in cursor.fetchall()}
+                 
+                 # 各分类统计
+                 cursor.execute('''
+                     SELECT category, COUNT(*) as count 
+                     FROM problems 
+                     GROUP BY category
+                 ''')
+                 category_stats = {row['category']: row['count'] for row in cursor.fetchall()}
+                 
+                 # 各部门统计
+                 cursor.execute('''
+                     SELECT department, COUNT(*) as count 
+                     FROM problems 
+                     WHERE department IS NOT NULL
+                     GROUP BY department
+                 ''')
+                 department_stats = {row['department']: row['count'] for row in cursor.fetchall()}
+                 
+                 # 今日新增（使用北京时间）
+                 cursor.execute('''
+                     SELECT COUNT(*) as count 
+                     FROM problems 
+                     WHERE DATE(created_at) = ?
+                 ''', (today_date,))
+                 today_new = cursor.fetchone()['count']
+                 
+                 # 本周新增（使用北京时间）
+                 cursor.execute('''
+                     SELECT COUNT(*) as count 
+                     FROM problems 
+                     WHERE DATE(created_at) >= ?
+                 ''', (week_start,))
+                 week_new = cursor.fetchone()['count']
+                 
+                 return {
+                     'total_problems': total_problems,
+                     'status_stats': status_stats,
+                     'category_stats': category_stats,
+                     'department_stats': department_stats,
+                     'today_new': today_new,
+                     'week_new': week_new
+                 }
+                 
+         except Exception as e:
+             logger.error(f"获取统计数据失败: {e}")
+             return {}
+     
+ 
+     def _clean_content_thoroughly(self, content: str) -> str:
+         """彻底清理内容，绝不返回HTML"""
+         if not content:
+             return ""
+         
+         original_content = content
+         
+         try:
+             # 导入必要的模块
+             import html
+             from bs4 import BeautifulSoup
+             
+             # 方法1: BeautifulSoup清理
+             soup = BeautifulSoup(content, 'html.parser')
+             clean_text = soup.get_text(strip=True)
+             
+             # 清理HTML实体
+             clean_text = html.unescape(clean_text)
+             
+             # 清理多余空白
+             clean_text = re.sub(r'\s+', ' ', clean_text).strip()
+             
+             # 验证清理效果
+             if clean_text and not ('<' in clean_text and '>' in clean_text):
+                 return clean_text
+                 
+         except Exception as e:
+             logger.warning(f"BeautifulSoup清理失败: {e}")
+         
+         try:
+             # 方法2: 正则表达式强制清理
+             clean_text = re.sub(r'<[^>]*>', '', original_content)
+             clean_text = re.sub(r'&[a-zA-Z0-9#]+;', '', clean_text)
+             clean_text = re.sub(r'\s+', ' ', clean_text).strip()
+             
+             if clean_text:
+                 return clean_text
+                 
+         except Exception as e:
+             logger.warning(f"正则表达式清理失败: {e}")
+         
+         # 方法3: 字符级清理（最后手段）
+         try:
+             clean_chars = []
+             skip_until_close = False
+             
+             for char in original_content:
+                 if char == '<':
+                     skip_until_close = True
+                 elif char == '>' and skip_until_close:
+                     skip_until_close = False
+                 elif not skip_until_close:
+                     clean_chars.append(char)
+             
+             clean_text = ''.join(clean_chars)
+             clean_text = re.sub(r'\s+', ' ', clean_text).strip()
+             
+             if clean_text:
+                 return clean_text
+                 
+         except Exception as e:
+             logger.warning(f"字符级清理失败: {e}")
+         
+         # 最终方案：返回安全的默认内容
+         logger.error(f"所有清理方法都失败，返回默认内容。原始内容长度: {len(original_content)}")
+         return "内容解析中..."
+ 
+     def _format_problem_data(self, problem) -> Dict:
+         """格式化问题数据"""
+         # 确保problem是字典类型
+         if hasattr(problem, 'keys'):
+             # 如果是sqlite3.Row对象，转换为字典
+             problem_dict = dict(problem)
+         else:
+             problem_dict = problem
+         
+         created_at = problem_dict['created_at']
+         post_time = self._calculate_time_diff(created_at)
+         
+         # 格式化创建时间为北京时间
+         formatted_created_at = created_at
+         try:
+             if created_at:
+                 # 使用新的时间解析函数
+                 created_time = self._parse_datetime(created_at)
+                 if created_time:
+                     # 直接格式化为北京时间显示格式
+                     formatted_created_at = created_time.strftime('%Y年%m月%d日 %H:%M')
+                 else:
+                     # 如果解析失败，保持原始格式
+                     formatted_created_at = created_at
+         except Exception as e:
+             logger.error(f"时间格式化错误: {e}")
+             formatted_created_at = created_at
+         
+         # 获取处理记录
+         processing_records = []
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 cursor.execute('''
+                     SELECT * FROM processing_records 
+                     WHERE problem_id = ? 
+                     ORDER BY created_at ASC
+                 ''', (problem_dict['id'],))
+                 processing_records = cursor.fetchall()
+         except Exception as e:
+             logger.error(f"获取处理记录失败: {e}")
+         
+         # 计算状态
+         status_text = self._calculate_status_for_display(
+             problem_dict.get('status', '待处理') if hasattr(problem_dict, 'get') else (problem_dict['status'] if 'status' in problem_dict.keys() else '待处理'),
+             processing_records,
+             problem_dict.get('is_processing', False) if hasattr(problem_dict, 'get') else (problem_dict['is_processing'] if 'is_processing' in problem_dict.keys() else False),
+             problem_dict.get('is_resolved', False) if hasattr(problem_dict, 'get') else (problem_dict['is_resolved'] if 'is_resolved' in problem_dict.keys() else False)
+         )
+         
+         # 处理HTML内容 - 修复版本（绝不返回HTML）
+         description_html = problem_dict['description']
+         try:
+             # 使用彻底的清理方法
+             description_text = self._clean_content_thoroughly(description_html)
+             
+         except Exception as e:
+             logger.error(f"HTML处理错误: {e}")
+             description_text = "内容解析中..."
+ 
+         # 获取点赞/踩数量
+         reaction_counts = self.get_reaction_counts(problem_dict['id'])
+         
+         # 获取真实浏览量
+         views_count = self.get_problem_views_count(problem_dict['id'])
+         
+         return {
+             'id': problem_dict['id'],
+             'title': problem_dict['title'],
+             'status': status_text,
+             'content': description_text,  # 使用处理后的纯文本内容
+             'description': description_text,  # 为了兼容性，同时保留description字段
+             'author': problem_dict['author'] if problem_dict['author'] else '匿名用户',
+             'post_time': post_time,
+             'views': views_count,  # 使用真实的浏览量
+             'comments': problem_dict.get('comment_count', 0) if hasattr(problem_dict, 'get') else (problem_dict['comment_count'] if 'comment_count' in problem_dict.keys() else 0),
+             'likes': reaction_counts.get('like', 0),  # 使用真实的点赞数量
+             'dislikes': reaction_counts.get('dislike', 0),  # 使用真实的踩数量
+             'hashtag': f"#{problem_dict['category']}#",
+             'is_new': self._is_new_post(created_at),
+             'category': problem_dict['category'],
+             'department': problem_dict['department'] if 'department' in problem_dict.keys() else None,
+             'response_department': problem_dict['response_department'] if 'response_department' in problem_dict.keys() else None,
+             'priority': problem_dict['priority'] if 'priority' in problem_dict.keys() else '普通',
+             'work_order': f"NO.BI{problem_dict['id']:012d}",
+             'created_at': formatted_created_at,
+             'updated_at': problem_dict['updated_at'] if 'updated_at' in problem_dict.keys() else created_at,
+             'processing_unit': problem_dict['processing_unit'] if 'processing_unit' in problem_dict.keys() else None,
+             'processing_person': problem_dict['processing_person'] if 'processing_person' in problem_dict.keys() else None,
+             'processing_status': problem_dict['processing_status'] if 'processing_status' in problem_dict.keys() else '待处理',
+             'is_processing': problem_dict['is_processing'] if 'is_processing' in problem_dict.keys() else False,
+             'is_resolved': problem_dict['is_resolved'] if 'is_resolved' in problem_dict.keys() else False
+         }
+     
+     def _parse_datetime(self, created_at: str) -> Optional[datetime]:
+         """解析时间字符串 - 支持多种格式"""
+         if not created_at:
+             return None
+         
+         # 定义可能的时间格式
+         time_formats = [
+             '%Y-%m-%d %H:%M:%S',  # 标准格式
+             '%Y-%m-%d %H:%M:%S.%f',  # 带毫秒格式
+             '%Y-%m-%d %H:%M',  # 无秒格式
+             '%Y-%m-%d',  # 仅日期格式
+             '%Y/%m/%d %H:%M:%S',  # 斜杠分隔格式
+             '%Y/%m/%d %H:%M',  # 斜杠分隔无秒格式
+         ]
+         
+         for fmt in time_formats:
+             try:
+                 return datetime.strptime(created_at, fmt)
+             except ValueError:
+                 continue
+         
+         # 如果所有格式都失败，记录错误并返回None
+         logger.error(f"无法解析时间格式: {created_at}")
+         return None
+ 
+     def _calculate_time_diff(self, created_at: str) -> str:
+         """计算时间差 - 使用北京时间（修复版本）"""
+         if not created_at:
+             return '刚刚'
+         
+         created_time = self._parse_datetime(created_at)
+         if not created_time:
+             return '刚刚'
+         
+         try:
+             # 获取北京时间时区
+             beijing_timezone = pytz.timezone('Asia/Shanghai')
+             
+             # 获取当前北京时间
+             now_beijing = datetime.now(beijing_timezone)
+             
+             # 关键修复：检查created_time是否已经有时区信息
+             if created_time.tzinfo is None:
+                 # 如果没有时区信息，假设是北京时间
+                 created_time_beijing = beijing_timezone.localize(created_time)
+             else:
+                 # 如果已有时区信息，转换为北京时间
+                 created_time_beijing = created_time.astimezone(beijing_timezone)
+             
+             # 计算时间差
+             time_diff = now_beijing - created_time_beijing
+             
+             if time_diff.days > 0:
+                 return f'{time_diff.days}天前'
+             elif time_diff.seconds >= 3600:
+                 hours = time_diff.seconds // 3600
+                 return f'{hours}小时前'
+             elif time_diff.seconds >= 60:
+                 minutes = time_diff.seconds // 60
+                 return f'{minutes}分钟前'
+             else:
+                 return '刚刚'
+         except Exception as e:
+             logger.error(f"时间差计算错误: {e}")
+             return '刚刚'
+     
+     def _calculate_status_for_display(self, status: str, processing_records, is_processing, is_resolved) -> str:
+         """计算状态显示文本 - 与统计方法保持一致"""
+         if not status:
+             return "待处理"
+         
+         # 根据处理记录和状态字段判断实际状态
+         if is_resolved:
+             return "已办结"
+         elif is_processing or (processing_records and len(processing_records) > 0):
+             # 如果有处理记录，进一步判断是否为已处理回复
+             if status == '已处理回复':
+                 return "已处理回复"
+             else:
+                 return "处理中"
+         elif status == '已派发':
+             return "已派发"
+         else:
+             return "待处理"
+     
+     def _is_new_post(self, created_at: str) -> bool:
+         """判断是否为新帖子 - 使用北京时间（修复版本）"""
+         if not created_at:
+             return True
+         
+         created_time = self._parse_datetime(created_at)
+         if not created_time:
+             return True
+         
+         try:
+             # 获取北京时间时区
+             beijing_timezone = pytz.timezone('Asia/Shanghai')
+             
+             # 获取当前北京时间
+             now_beijing = datetime.now(beijing_timezone)
+             
+             # 关键修复：检查created_time是否已经有时区信息
+             if created_time.tzinfo is None:
+                 # 如果没有时区信息，假设是北京时间
+                 created_time_beijing = beijing_timezone.localize(created_time)
+             else:
+                 # 如果已有时区信息，转换为北京时间
+                 created_time_beijing = created_time.astimezone(beijing_timezone)
+             
+             # 计算时间差
+             time_diff = now_beijing - created_time_beijing
+             return time_diff.days < 1
+         except Exception as e:
+             logger.error(f"新帖子判断错误: {e}")
+             return True
+ 
+     def add_processing_record(self, problem_id: int, processor: str, measure: str, 
+                             department: Optional[str] = None, assigned_to: Optional[str] = None) -> bool:
+         """添加处理记录"""
+         try:
+             # 清理输入内容，防止HTML污染
+             cleaned_processor = self._clean_html_content(processor)
+             cleaned_measure = self._clean_html_content(measure)
+             cleaned_department = self._clean_html_content(department) if department else None
+             cleaned_assigned_to = self._clean_html_content(assigned_to) if assigned_to else None
+             
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 # 获取当前北京时间
+                 beijing_timezone = pytz.timezone('Asia/Shanghai')
+                 now_beijing = datetime.now(beijing_timezone)
+                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
+                 
+                 cursor.execute('''
+                     INSERT INTO processing_records (problem_id, processor, measure, department, assigned_to, created_at)
+                     VALUES (?, ?, ?, ?, ?, ?)
+                 ''', (problem_id, cleaned_processor, cleaned_measure, cleaned_department, cleaned_assigned_to, current_time))
+                 
+                 conn.commit()
+                 logger.info(f"处理记录添加成功: {problem_id}")
+                 return True
+                 
+         except Exception as e:
+             logger.error(f"添加处理记录失败: {e}")
+             return False
+     
+     def start_processing(self, problem_id: int, processor: str, processing_unit: str = None) -> bool:
+         """开始处理问题（接单）"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 # 获取当前北京时间
+                 beijing_timezone = pytz.timezone('Asia/Shanghai')
+                 now_beijing = datetime.now(beijing_timezone)
+                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
+                 
+                 cursor.execute('''
+                     UPDATE problems 
+                     SET is_processing = 1, 
+                         processing_person = ?, 
+                         processing_unit = ?,
+                         processing_status = '处理中',
+                         updated_at = ? 
+                     WHERE id = ?
+                 ''', (processor, processing_unit, current_time, problem_id))
+                 
+                 # 记录状态变更
+                 cursor.execute('''
+                     INSERT INTO status_logs (problem_id, old_status, new_status, operator, comment, created_at)
+                     VALUES (?, ?, ?, ?, ?, ?)
+                 ''', (problem_id, '待处理', '处理中', processor, '接单处理', current_time))
+                 
+                 conn.commit()
+                 logger.info(f"问题开始处理: {problem_id} -> {processor}")
+                 return True
+                 
+         except Exception as e:
+             logger.error(f"开始处理失败: {e}")
+             return False
+     
+     def resolve_problem(self, problem_id: int, processor: str, resolution_note: str = None) -> bool:
+         """完结问题"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 # 确保processor不为空
+                 if not processor:
+                     processor = "系统管理员"
+                 
+                 # 获取当前北京时间
+                 beijing_timezone = pytz.timezone('Asia/Shanghai')
+                 now_beijing = datetime.now(beijing_timezone)
+                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
+                 
+                 cursor.execute('''
+                     UPDATE problems 
+                     SET is_resolved = 1, 
+                         processing_status = '已完结',
+                         updated_at = ? 
+                     WHERE id = ?
+                 ''', (current_time, problem_id))
+                 
+                 # 记录状态变更
+                 cursor.execute('''
+                     INSERT INTO status_logs (problem_id, old_status, new_status, operator, comment, created_at)
+                     VALUES (?, ?, ?, ?, ?, ?)
+                 ''', (problem_id, '处理中', '已完结', processor, resolution_note or '问题已完结', current_time))
+                 
+                 conn.commit()
+                 logger.info(f"问题已完结: {problem_id} -> {processor}")
+                 return True
+                 
+         except Exception as e:
+             logger.error(f"完结问题失败: {e}")
+             return False
+     
+     def get_processing_records(self, problem_id: int) -> List[Dict]:
+         """获取问题的处理记录列表"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 cursor.execute('''
+                     SELECT * FROM processing_records 
+                     WHERE problem_id = ? 
+                     ORDER BY created_at ASC
+                 ''', (problem_id,))
+                 
+                 records = []
+                 for record in cursor.fetchall():
+                     # 安全地访问 SQLite Row 对象
+                     try:
+                         department = record['department'] if 'department' in record.keys() else None
+                     except (KeyError, TypeError):
+                         department = None
+                     
+                     try:
+                         assigned_to = record['assigned_to'] if 'assigned_to' in record.keys() else None
+                     except (KeyError, TypeError):
+                         assigned_to = None
+                     
+                     records.append({
+                         'id': record['id'],
+                         'processor': record['processor'],
+                         'measure': record['measure'],
+                         'department': department,
+                         'assigned_to': assigned_to,
+                         'created_at': record['created_at']
+                     })
+                 
+                 return records
+                 
+         except Exception as e:
+             logger.error(f"获取处理记录失败: {e}")
+             return []
+ 
+     def add_reaction(self, problem_id: int, user_id: str, reaction_type: str) -> bool:
+         """添加点赞或踩"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 # 获取当前北京时间
+                 beijing_timezone = pytz.timezone('Asia/Shanghai')
+                 now_beijing = datetime.now(beijing_timezone)
+                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
+                 
+                 # 检查是否已经存在反应
+                 cursor.execute('''
+                     SELECT reaction_type FROM reactions 
+                     WHERE problem_id = ? AND user_id = ?
+                 ''', (problem_id, user_id))
+                 
+                 existing = cursor.fetchone()
+                 
+                 if existing:
+                     if existing['reaction_type'] == reaction_type:
+                         # 如果点击相同类型，则取消
+                         cursor.execute('''
+                             DELETE FROM reactions 
+                             WHERE problem_id = ? AND user_id = ?
+                         ''', (problem_id, user_id))
+                     else:
+                         # 如果点击不同类型，则更新
+                         cursor.execute('''
+                             UPDATE reactions 
+                             SET reaction_type = ?, created_at = ? 
+                             WHERE problem_id = ? AND user_id = ?
+                         ''', (reaction_type, current_time, problem_id, user_id))
+                 else:
+                     # 添加新的反应
+                     cursor.execute('''
+                         INSERT INTO reactions (problem_id, user_id, reaction_type, created_at)
+                         VALUES (?, ?, ?, ?)
+                     ''', (problem_id, user_id, reaction_type, current_time))
+                 
+                 conn.commit()
+                 logger.info(f"反应添加成功: {problem_id} -> {reaction_type}")
+                 return True
+                 
+         except Exception as e:
+             logger.error(f"添加反应失败: {e}")
+             return False
+ 
+     def get_reaction_counts(self, problem_id: int) -> Dict[str, int]:
+         """获取问题的点赞/踩数量"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 cursor.execute('''
+                     SELECT reaction_type, COUNT(*) as count
+                     FROM reactions 
+                     WHERE problem_id = ?
+                     GROUP BY reaction_type
+                 ''', (problem_id,))
+                 
+                 counts = {'like': 0, 'dislike': 0}
+                 for row in cursor.fetchall():
+                     counts[row['reaction_type']] = row['count']
+                 
+                 return counts
+                 
+         except Exception as e:
+             logger.error(f"获取反应数量失败: {e}")
+             return {'like': 0, 'dislike': 0}
+ 
+     def get_user_reaction(self, problem_id: int, user_id: str) -> Optional[str]:
+         """获取用户对问题的反应"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 cursor.execute('''
+                     SELECT reaction_type FROM reactions 
+                     WHERE problem_id = ? AND user_id = ?
+                 ''', (problem_id, user_id))
+                 
+                 result = cursor.fetchone()
+                 return result['reaction_type'] if result else None
+                 
+         except Exception as e:
+             logger.error(f"获取用户反应失败: {e}")
+             return None
+ 
+     def _init_default_permissions(self, cursor):
+         """初始化默认权限"""
+         permissions = [
+             # 普通用户权限
+             ('user', 'problem', 'view'),
+             ('user', 'problem', 'create'),
+             ('user', 'problem', 'comment'),
+             ('user', 'problem', 'like'),
+             
+             # 处理人权限
+             ('processor', 'problem', 'view'),
+             ('processor', 'problem', 'create'),
+             ('processor', 'problem', 'comment'),
+             ('processor', 'problem', 'like'),
+             ('processor', 'problem', 'process'),
+             ('processor', 'problem', 'update_status'),
+             ('processor', 'problem', 'add_record'),
+             
+             # 经理权限
+             ('manager', 'problem', 'view'),
+             ('manager', 'problem', 'create'),
+             ('manager', 'problem', 'comment'),
+             ('manager', 'problem', 'like'),
+             ('manager', 'problem', 'process'),
+             ('manager', 'problem', 'update_status'),
+             ('manager', 'problem', 'add_record'),
+             ('manager', 'problem', 'assign'),
+             ('manager', 'problem', 'export'),
+             ('manager', 'user', 'view'),
+             
+             # 管理员权限
+             ('admin', 'problem', 'view'),
+             ('admin', 'problem', 'create'),
+             ('admin', 'problem', 'comment'),
+             ('admin', 'problem', 'like'),
+             ('admin', 'problem', 'process'),
+             ('admin', 'problem', 'update_status'),
+             ('admin', 'problem', 'add_record'),
+             ('admin', 'problem', 'assign'),
+             ('admin', 'problem', 'export'),
+             ('admin', 'problem', 'delete'),
+             ('admin', 'user', 'view'),
+             ('admin', 'user', 'create'),
+             ('admin', 'user', 'update'),
+             ('admin', 'user', 'delete'),
+             ('admin', 'system', 'config'),
+         ]
+         
+         for role, resource, action in permissions:
+             cursor.execute('''
+                 INSERT OR IGNORE INTO permissions (role, resource, action)
+                 VALUES (?, ?, ?)
+             ''', (role, resource, action))
+ 
+     def _init_default_admin(self, cursor):
+         """初始化默认管理员账户"""
+         import hashlib
+         
+         # 检查是否已存在管理员
+         cursor.execute('SELECT COUNT(*) FROM users WHERE role = "admin"')
+         if cursor.fetchone()[0] == 0:
+             # 创建默认管理员账户
+             default_password = "admin123"  # 实际应用中应该使用更安全的密码
+             password_hash = hashlib.sha256(default_password.encode()).hexdigest()
+             
+             cursor.execute('''
+                 INSERT INTO users (username, password_hash, real_name, role, department)
+                 VALUES (?, ?, ?, ?, ?)
+             ''', ('admin', password_hash, '系统管理员', 'admin', '系统管理部'))
+             
+             logger.info("默认管理员账户已创建: admin/admin123")
+ 
+     def get_all_users(self):
+         """获取所有用户"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 cursor.execute('''
+                     SELECT id, username, real_name, email, department, role, is_active, created_at
+                     FROM users ORDER BY created_at DESC
+                 ''')
+                 return cursor.fetchall()
+         except Exception as e:
+             logger.error(f"获取用户列表失败: {e}")
+             return []
+ 
+     def add_user(self, username, password, real_name, email=None, department=None, role='user'):
+         """添加用户"""
+         try:
+             import hashlib
+             password_hash = hashlib.sha256(password.encode()).hexdigest()
+             
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 cursor.execute('''
+                     INSERT INTO users (username, password_hash, real_name, email, department, role)
+                     VALUES (?, ?, ?, ?, ?, ?)
+                 ''', (username, password_hash, real_name, email, department, role))
+                 conn.commit()
+                 return True
+         except Exception as e:
+             logger.error(f"添加用户失败: {e}")
+             return False
+ 
+     def update_user(self, user_id, **kwargs):
+         """更新用户信息"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 # 构建更新语句
+                 update_fields = []
+                 params = []
+                 
+                 for key, value in kwargs.items():
+                     if key in ['real_name', 'email', 'department', 'role', 'is_active']:
+                         update_fields.append(f"{key} = ?")
+                         params.append(value)
+                 
+                 if update_fields:
+                     params.append(user_id)
+                     cursor.execute(f'''
+                         UPDATE users SET {', '.join(update_fields)}
+                         WHERE id = ?
+                     ''', params)
+                     conn.commit()
+                     return True
+         except Exception as e:
+             logger.error(f"更新用户失败: {e}")
+             return False
+ 
+     def get_status_logs(self, problem_id: int) -> List[Dict]:
+         """获取问题的状态变更记录"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 cursor.execute('''
+                     SELECT * FROM status_logs 
+                     WHERE problem_id = ? 
+                     ORDER BY created_at ASC
+                 ''', (problem_id,))
+                 
+                 logs = []
+                 for log in cursor.fetchall():
+                     logs.append({
+                         'id': log['id'],
+                         'operator': log['operator'],
+                         'old_status': log['old_status'],
+                         'new_status': log['new_status'],
+                         'comment': log['comment'],
+                         'created_at': log['created_at']
+                     })
+                 
+                 return logs
+                 
+         except Exception as e:
+             logger.error(f"获取状态日志失败: {e}")
+             return []
+ 
+     def get_comment_replies(self, comment_id: int) -> List[Dict]:
+         """获取评论的回复列表"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 cursor.execute('''
+                     SELECT * FROM comment_replies 
+                     WHERE comment_id = ? 
+                     ORDER BY created_at ASC
+                 ''', (comment_id,))
+                 
+                 replies = []
+                 for reply in cursor.fetchall():
+                     replies.append({
+                         'id': reply['id'],
+                         'author': reply['author'],
+                         'content': reply['content'],
+                         'created_at': reply['created_at']
+                     })
+                 
+                 return replies
+                 
+         except Exception as e:
+             logger.error(f"获取评论回复失败: {e}")
+             return []
+ 
+     def add_comment_reply(self, comment_id: int, author: str, content: str) -> bool:
+         """添加评论回复"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 # 获取当前北京时间
+                 beijing_timezone = pytz.timezone('Asia/Shanghai')
+                 now_beijing = datetime.now(beijing_timezone)
+                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
+                 
+                 cursor.execute('''
+                     INSERT INTO comment_replies (comment_id, author, content, created_at)
+                     VALUES (?, ?, ?, ?)
+                 ''', (comment_id, author, content, current_time))
+                 
+                 conn.commit()
+                 logger.info(f"评论回复添加成功: {comment_id}")
+                 return True
+                 
+         except Exception as e:
+             logger.error(f"添加评论回复失败: {e}")
+             return False
+ 
+     def record_problem_view(self, problem_id: int, user_id: str = None, ip_address: str = None) -> bool:
+         """记录问题浏览量"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 # 获取当前北京时间
+                 beijing_timezone = pytz.timezone('Asia/Shanghai')
+                 now_beijing = datetime.now(beijing_timezone)
+                 current_time = now_beijing.strftime('%Y-%m-%d %H:%M:%S')
+                 
+                 cursor.execute('''
+                     INSERT INTO problem_views (problem_id, user_id, ip_address, viewed_at)
+                     VALUES (?, ?, ?, ?)
+                 ''', (problem_id, user_id, ip_address, current_time))
+                 
+                 conn.commit()
+                 logger.info(f"浏览量记录成功: {problem_id}")
+                 return True
+                 
+         except Exception as e:
+             logger.error(f"记录浏览量失败: {e}")
+             return False
+ 
      def get_problem_views_count(self, problem_id: int) -> int:
          """获取问题的浏览量"""
              return False
  
+     def get_work_orders(self, user_info: Dict, filters: Dict = None) -> List[Dict]:
+         """获取工单列表 - 显示与自己关联过的所有工单"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 user_role = user_info['role']
+                 user_name = user_info['real_name']
+                 user_department = user_info.get('department', '')
+                 
+                 # 构建基础查询
+                 if user_role == 'admin':
+                     # admin可以看到所有工单
+                     base_query = '''
+                         SELECT p.*, 
+                                COUNT(pr.id) as processing_records_count
+                         FROM problems p
+                         LEFT JOIN processing_records pr ON p.id = pr.problem_id
+                     '''
+                     where_conditions = []
+                     params = []
+                 else:
+                     # 根据用户部门进行权限过滤 - 支持多部门
+                     if user_department == '调度中心':
+                         # 调度中心用户：可以看到所有工单（因为调度中心需要全局视角）
+                         base_query = '''
+                             SELECT p.*, 
+                                    COUNT(pr.id) as processing_records_count
+                             FROM problems p
+                             LEFT JOIN processing_records pr ON p.id = pr.problem_id
+                         '''
+                         where_conditions = []
+                         params = []
+                     else:
+                         # 其他部门用户：可以看到与自己关联过的所有工单
+                         # 包括：1. 自己部门创建的工单 2. 分配给自己部门的工单 3. 自己部门处理过的工单
+                         base_query = '''
+                             SELECT p.*, 
+                                    COUNT(pr.id) as processing_records_count
+                             FROM problems p
+                             LEFT JOIN processing_records pr ON p.id = pr.problem_id
+                         '''
+                         where_conditions = [
+                             '(p.department = ? OR p.response_department = ? OR ' +
+                             'EXISTS (SELECT 1 FROM problem_departments pd WHERE pd.problem_id = p.id AND pd.department = ?) OR ' +
+                             'EXISTS (SELECT 1 FROM processing_records pr2 WHERE pr2.problem_id = p.id AND pr2.department = ?))'
+                         ]
+                         params = [user_department, user_department, user_department, user_department]
+                 
+                 # 添加筛选条件
+                 if filters:
+                     if filters.get('status'):
+                         where_conditions.append('p.status = ?')
+                         params.append(filters['status'])
+                     
+                     if filters.get('category'):
+                         where_conditions.append('p.category = ?')
+                         params.append(filters['category'])
+                     
+                     if filters.get('priority'):
+                         where_conditions.append('p.priority = ?')
+                         params.append(filters['priority'])
+                     
+                     if filters.get('department'):
+                         where_conditions.append('p.department = ?')
+                         params.append(filters['department'])
+                     
+                     if filters.get('date_range'):
+                         start_date, end_date = filters['date_range']
+                         where_conditions.append('DATE(p.created_at) BETWEEN ? AND ?')
+                         params.extend([start_date, end_date])
+                     
+                     if filters.get('search'):
+                         search_term = f"%{filters['search']}%"
+                         where_conditions.append('(p.title LIKE ? OR p.description LIKE ?)')
+                         params.extend([search_term, search_term])
+                 
+                 # 组合查询
+                 if where_conditions:
+                     query = base_query + ' WHERE ' + ' AND '.join(where_conditions) + ' GROUP BY p.id ORDER BY p.created_at DESC'
+                 else:
+                     query = base_query + ' GROUP BY p.id ORDER BY p.created_at DESC'
+                 
+                 cursor.execute(query, params)
+                 
+                 problems = []
+                 for row in cursor.fetchall():
+                     problems.append(self._format_problem_data(row))
+                 
+                 return problems
+                 
+         except Exception as e:
+             logger.error(f"获取工单列表失败: {e}")
+             return []
+ 
  # 创建全局数据库管理器实例
  db = DatabaseManager()
```

---



---



---


<!-- Generated by SpecStory -->

# 继续分析和完善处理 (2025-08-10 07:55:02)

_**User**_

继续分析处理

---

_**Assistant**_

我继续分析并完善处理。让我查看当前的实现状态，然后完成剩余的功能：


---

Read file: db_manager.py

---

我看到代码中有重复的函数定义。让我查看完整的 `get_work_orders` 函数：


---

Read file: db_manager.py

---

我发现代码中有重复的函数定义。让我清理这些重复的函数，并完善实现。首先删除重复的函数：


---

```diff
              return []
  
+     def get_work_order_statistics(self, user_info: Dict) -> Dict[str, int]:
+         """获取工单统计信息 - 显示与自己关联过的所有工单数量"""
+         try:
+             with self._get_connection() as conn:
+                 cursor = conn.cursor()
+                 
+                 user_role = user_info['role']
+                 user_name = user_info['real_name']
+                 user_department = user_info.get('department', '')
+                 
+                 # 构建基础查询
+                 if user_role == 'admin':
+                     # admin可以看到所有工单统计
+                     cursor.execute('''
+                         SELECT p.*, 
+                                COUNT(pr.id) as processing_records_count
+                         FROM problems p
+                         LEFT JOIN processing_records pr ON p.id = pr.problem_id
+                         GROUP BY p.id
+                     ''')
+                 else:
+                     # 根据用户部门进行权限过滤 - 支持多部门
+                     if user_department == '调度中心':
+                         # 调度中心用户：可以看到所有工单的统计（因为调度中心需要全局视角）
+                         cursor.execute('''
+                             SELECT p.*, 
+                                    COUNT(pr.id) as processing_records_count
+                             FROM problems p
+                             LEFT JOIN processing_records pr ON p.id = pr.problem_id
+                             GROUP BY p.id
+                         ''')
+                     else:
+                         # 其他部门用户：可以看到与自己关联过的所有工单统计
+                         # 包括：1. 自己部门创建的工单 2. 分配给自己部门的工单 3. 自己部门处理过的工单
+                         cursor.execute('''
+                             SELECT p.*, 
+                                    COUNT(pr.id) as processing_records_count
+                             FROM problems p
+                             LEFT JOIN processing_records pr ON p.id = pr.problem_id
+                             WHERE p.department = ? OR 
+                                   p.response_department = ? OR
+                                   EXISTS (SELECT 1 FROM problem_departments pd WHERE pd.problem_id = p.id AND pd.department = ?) OR
+                                   EXISTS (SELECT 1 FROM processing_records pr2 WHERE pr2.problem_id = p.id AND pr2.department = ?)
+                             GROUP BY p.id
+                         ''', (user_department, user_department, user_department, user_department))
+                 
+                 stats = {
+                     '待处理': 0,
+                     '已派发': 0,
+                     '处理中': 0,
+                     '已处理回复': 0,
+                     '已办结': 0
+                 }
+                 
+                 for row in cursor.fetchall():
+                     # 使用与表格相同的状态计算逻辑
+                     status = self._calculate_status_for_statistics(row)
+                     if status in stats:
+                         stats[status] += 1
+                 
+                 return stats
+                 
+         except Exception as e:
+             logger.error(f"获取工单统计失败: {e}")
+             return {
+                 '待处理': 0,
+                 '已派发': 0,
+                 '处理中': 0,
+                 '已处理回复': 0,
+                 '已办结': 0
+             }
+     
+     def _calculate_status_for_statistics(self, problem_row) -> str:
+         """为统计计算状态 - 按照新的规则"""
+         try:
+             # 获取基础状态
+             base_status = problem_row.get('status', '')
+             processing_records_count = problem_row.get('processing_records_count', 0)
+             
+             # 根据处理记录数量判断状态
+             if processing_records_count == 0:
+                 return '待处理'
+             elif processing_records_count == 1:
+                 return '已派发'
+             elif processing_records_count == 2:
+                 return '处理中'
+             elif processing_records_count == 3:
+                 return '已处理回复'
+             elif processing_records_count >= 4:
+                 return '已办结'
+             else:
+                 return base_status
+                 
+         except Exception as e:
+             logger.error(f"计算统计状态失败: {e}")
+             return '待处理'
+ 
+     def can_user_operate_work_order(self, user_info: Dict, problem_data: Dict) -> bool:
+         """判断用户是否可以操作工单 - 只有当前主要处理部门是自己的部门才显示操作按钮"""
+         try:
+             user_role = user_info['role']
+             user_department = user_info.get('department', '')
+             
+             # admin可以操作所有工单
+             if user_role == 'admin':
+                 return True
+             
+             # 调度中心用户可以操作所有工单
+             if user_department == '调度中心':
+                 return True
+             
+             # 其他用户：只有当前主要处理部门是自己的部门才能操作
+             current_primary_department = problem_data.get('response_department', '')
+             
+             # 检查是否是当前主要处理部门
+             if current_primary_department == user_department:
+                 return True
+             
+             # 检查problem_departments表中是否有主要部门记录
+             try:
+                 with self._get_connection() as conn:
+                     cursor = conn.cursor()
+                     cursor.execute('''
+                         SELECT is_primary FROM problem_departments 
+                         WHERE problem_id = ? AND department = ?
+                     ''', (problem_data['id'], user_department))
+                     
+                     result = cursor.fetchone()
+                     if result and result[0]:
+                         return True
+             except Exception as e:
+                 logger.error(f"检查部门权限失败: {e}")
+             
+             return False
+             
+         except Exception as e:
+             logger.error(f"判断用户操作权限失败: {e}")
+             return False
+ 
  # 创建全局数据库管理器实例
  db = DatabaseManager()
```

---

现在让我查看工单调度页面的代码，了解如何集成这些新的函数：


---

<details>
            <summary>Searched codebase "工单调度页面 streamlit 界面 统计数据 工单列表" • **15** results</summary>
        
| File | Lines |
|------|-------|
| `pages/工单调度.py` | L1477-1527 |
| `txt/工单调度.txt` | L823-876 |
| `pages/工单调度.py` | L1673-1699 |
| `txt/工单调度.txt` | L876-926 |
| `pages/工单调度.py` | L1554-1587 |
| `txt/工单调度.txt` | L926-971 |
| `pages/工单调度 - 副本.py` | L821-874 |
| `pages/工单调度.py` | L1699-1719 |
| `app.py` | L669-728 |
| `txt/工单调度.txt` | L713-735 |
| `pages/工单调度.py` | L1-88 |
| `pages/工单调度.py` | L1777-1808 |
| `pages/工单调度 - 副本.py` | L923-968 |
| `pages/工单调度.py` | L1656-1673 |
| `txt/工单调度.txt` | L1-84 |

</details>

---

现在让我查看工单调度页面的具体实现，了解如何集成新的权限控制：


---

Read file: pages/工单调度.py

---

现在让我查看工单操作权限控制的实现：


---

Read file: pages/工单调度.py

---



---



---

